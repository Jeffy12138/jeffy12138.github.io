<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[7.设置数据]]></title>
    <url>%2F2017%2F08%2F09%2F%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[本章介绍了将数据设置到各种类型的图表。 线型图如果要向图表添加值（数据），则必须通过 public void setData（ChartData data）{ ... } 方法。所述基类ChartData（ChartData）类封装了图表呈现期间所需的所有数据和信息。对于每种类型的图表，存在用于为图表设置数据的ChartData（例如LineData）的不同子类。在构造函数中，您可以将其List&lt;? extends IDataSet&gt;作为要显示的值进行切换。下面是一个LineData类（extends ChartData）的例子，用于将数据添加到LineChart： /**列表构造函数*/ public LineData（ List &lt; ILineDataSet &gt; sets）{ ... } /**构造与一个或多个ILineDataSet对象*/ 公共 LineData（ ILineDataSet 。..）{ ... } 那么，什么是一个DataSet，你为什么需要它？这其实很简单。一个DataSet对象表示图表中的Entry属于一起的一组条目（例如类）。它被设计为在图表中逻辑地分隔不同的值组。对于每种类型的图表，存在允许特定样式的扩展DataSet（例如LineDataSet）的不同对象。 例如，您可能希望显示在一年内两家不同公司的季度收入LineChart。在这种情况下，建议创建两个不同的LineDataSet对象，每个对象包含四个值（每个季度一个）。 当然，也可以LineDataSet为两个公司提供一个包含所有8个值的对象。 那么如何设置LineDataSet对象？ public LineDataSet（List &lt; Entry &gt; entries，String label）{ ... } 当查看构造函数（多种不同的构造函数可用）时，可以看到LineDataSet需要一个List类型Entry用于描述LineDataSet和一个String用作该标签的标签Legend。此外，此标签可用于查找对象中的LineDataSet 该List类型Entry封装了图表的所有值。一个Entry是围绕与x轴和y值在图表中的条目的的包装： public Entry（float x，float y）{ ... } 把它放在一起（两家公司季度收入超过一年的例子）： 首先，创建Entry类型列表来保存您的值： List&lt;Entry&gt; valsComp1 = new ArrayList&lt;Entry&gt;(); List&lt;Entry&gt; valsComp2 = new ArrayList&lt;Entry&gt;(); 然后，用Entry对象填写列表。确保条目对象包含x轴的正确索引。（当然，这里可以使用一个循环，在这种情况下，循环的计数器变量可以是x轴上的索引）。 Entry c1e1 = new Entry(0f, 100000f); // 0 == quarter 1 valsComp1.add(c1e1); Entry c1e2 = new Entry(1f, 140000f); // 1 == quarter 2 ... valsComp1.add(c1e2); // and so on ... Entry c2e1 = new Entry(0f, 130000f); // 0 == quarter 1 valsComp2.add(c2e1); Entry c2e2 = new Entry(1f, 115000f); // 1 == quarter 2 ... valsComp2.add(c2e2); //... 现在我们有了Entry对象列表，LineDataSet对象可以创建： LineDataSet setComp1 = new LineDataSet(valsComp1, &quot;Company 1&quot;); setComp1.setAxisDependency(AxisDependency.LEFT); LineDataSet setComp2 = new LineDataSet(valsComp2, &quot;Company 2&quot;); setComp2.setAxisDependency(AxisDependency.LEFT); 通过调用setAxisDependency(…)，DataSet应该绘制相对应的轴。但并非最后 最重要的是，我们创建一个IDataSets列表并构建我们的ChartData对象： //使用接口ILineDataSet List&lt;ILineDataSet&gt; dataSets = new ArrayList&lt;ILineDataSet&gt;(); dataSets.add(setComp1); dataSets.add(setComp2); LineData data = new LineData(dataSets); mLineChart.setData(data); mLineChart.invalidate(); //刷新 调用invalidate()后，图表刷新并展示所提供的数据。 如果我们要为x轴添加更多的描述性值（而不是不同季度的0到3的数字），我们可以通过使用IAxisValueFormatter接口来实现。这个界面允许XAxis自定义样式。在此示例中，格式化程序可能如下所示： //应该在XAxis上绘制的标签 final String[] quarters = new String[] { &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot; }; IAxisValueFormatter formatter = new IAxisValueFormatter() { @Override public String getFormattedValue(float value, AxisBase axis) { return quarters[(int) value]; } //我们不绘制数字，所以不需要十进制数字 @Override public int getDecimalDigits() { return 0; } }; XAxis xAxis = mLineChart.getXAxis(); xAxis.setGranularity(1f); // minimum axis-step（interval）为1 xAxis.setValueFormatter（格式化器）; 有关IAxisValueFormatter界面的详细信息，请参见此处。 如果应用了附加样式，则LineChart从此示例得到的样式应类似于以下内容： BarChart，ScatterChart，BubbleChart和CandleStickChart正常设定数据工作原理类似LineChart。一个特殊情况是BarChart有多个（分组）的条，这将在下面解释。 条目的顺序请注意，这个库并不正式支持从没有在上升方式中的条目的x位置排序的条目列表绘制折线图的数据。以未排序的方式添加条目可能会导致正确的绘制，但也可能导致意外的行为。一个Entry的List对象可以手动排序，也可以使用EntryXComparator： List&lt;Entry&gt; entries = ...; Collections.sort(entries, new EntryXComparator()); 必需是这样的原因是因为库使用二进制搜索算法来获得更好的性能，只能在排序列表上工作。 BARCHARTa BarChart设置数据的方式非常类似于LineChart。主要区别是需要用于设置数据的数据对象（例如，BarEntry而不是Entry）。除此之外，BarChart还有不同的风格选择。 请考虑以下填写BarChart数据的示例： List&lt;BarEntry&gt; entries = new ArrayList&lt;&gt;(); entries.add(new BarEntry(0f, 30f)); entries.add(new BarEntry(1f, 80f)); entries.add(new BarEntry(2f, 60f)); entries.add(new BarEntry(3f, 50f)); // gap of 2f entries.add(new BarEntry(5f, 70f)); entries.add(new BarEntry(6f, 60f)); BarDataSet set = new BarDataSet(entries, &quot;BarDataSet&quot;); 在上面的例子中，BarEntry创建了五个对象并将其添加到了BarDataSet。请注意，在第四个到第五个条目之间的x位置上存在“2”的差距。在这个例子中，这个差距用来解释杆在BarChart工程中的定位。本教程末尾的屏幕截图将显示BarChart给定数据的结果。作为下一步，BarData需要创建一个对象： BarData data = new BarData(set); data.setBarWidth(0.9f); //设置自定义栏宽度 chart.setData(data); chart.setFitBars(true); //使x轴完全适合所有酒吧 chart.invalidate(); //刷新 在上面的代码段中，BarData创建了一个对象。当BarEntry图表的对象创建时，我们在每个栏的（中心）之间的x轴上留下了一个“1f”空格。通过将条宽设置为0.9f，我们有效在每个条之间地创建一个0.1f的空间。setFitBars（true）调用会告诉图表调整它的x轴值的范围，以精确地适合所有的条，并且不会在两边切断条形。 创建BarData对象后，我们将其设置为图表并刷新。结果应该如下所示： 分组BarChart自版本V3.0.0以来，MPAndroidChart支持绘制条分组显式（在这种情况下，库将处理x位置）或用户定义，这意味着用户可以通过更改x位置来将栏放置在任何位置。 本节将重点介绍显式分组的BarChart，这意味着库将处理条的x位置。 请考虑以下示例设置： YourData[] group1 = ...; YourData[] group2 = ...; List&lt;BarEntry&gt; entriesGroup1 = new ArrayList&lt;&gt;(); List&lt;BarEntry&gt; entriesGroup2 = new ArrayList&lt;&gt;(); //填充列表 for(int i = 0; i &lt; group1.length; i++) { entriesGroup1.add(new BarEntry(i, group1.getValue())); entriesGroup2.add(new BarEntry(i, group2.getValue())); } BarDataSet set1 = new BarDataSet(entriesGroup1, &quot;Group 1&quot;); BarDataSet set2 = new BarDataSet(entriesGroup2, &quot;Group 2&quot;); 在这个例子中，我们将有两组条，每组由一个BarDataSet表示。 在显式（处理库）的情况下，条目的实际x位置并不重要。 根据条目列表中BarEntry的位置执行分组。 float groupSpace = 0.06f; float barSpace = 0.02f; // x2 dataset float barWidth = 0.45f; // x2 dataset // (0.02 + 0.45) * 2 + 0.06 = 1.00 -&gt; interval per &quot;group&quot; BarData data = new BarData(set1, set2); data.setBarWidth(barWidth); // set the width of each bar barChart.setData(data); barChart.groupBars(1980f, groupSpace, barSpace); // perform the &quot;explicit&quot; grouping barChart.invalidate(); // refresh 在上面的代码片段中，BarDataSet对象被添加到BarChart。 groupBars（…）方法执行两个BarDataSet对象的分组。 该方法采用以下参数： public void groupBars（float fromX，float groupSpace，float barSpace）{ ... } 该fromX参数确定XAxis分组栏应该在何处开始（在这种情况下为“1980”），groupSpace确定每组条之间留下的空间，barSpace确定组中单个条之间的空格。基于这些参数，该groupBars(…)方法改变每个条的XAxis朝向分组外观的位置，保持各个BarEntry对象的顺序。 每个组中的“间隔”（占用空间）XAxis也由参数groupSpace和barSpace参数定义barWidth。 结果应该是这样的： 当然，分组的BarChart也可以在不使用groupBars（…）方法的情况下实现，只需通过手动将各个条直接定位到XAxis上即可。 为了确保在XAxis上面的屏幕截图中的标签位于组之上，您可以使用以下setCenterAxisLabels(…)方法： XAxis xAxis = chart.getXAxis(); xAxis.setCenterAxisLabels(true); 堆叠BarChart堆叠的BarChart设置与普通的BarChart完全相似，除了BarEntry创建各个对象的方式之外。在堆叠条形的情况下，BarEntry必须使用不同的构造函数： public BarEntry（float x，float [] yValues）{ ... } 该构造函数允许提供多个yValues，它们表示每个栏的“堆栈”的值。考虑下面的示例对象： BarEntry stackedEntry = new BarEntry(0f, new float[] { 10, 20, 30 }); 这BarEntry包括三个值的堆叠，“高”为“10”，“20”和“30”。 PieChart与其他图表类型不同，PieChart以PieEntry对象的形式获取数据。 这些对象的构造函数如下所示： public PieEntry（float value，String label）{ ... } 构造函数的第一个参数用于在PieChart中应该绘制为饼图的实际“值”。 称为“label”的第二个String参数用于提供切片的其他描述。 请考虑以下示例PieChart设置： List&lt;PieEntry&gt; entries = new ArrayList&lt;&gt;(); entries.add(new PieEntry(18.5f, &quot;Green&quot;)); entries.add(new PieEntry(26.7f, &quot;Yellow&quot;)); entries.add(new PieEntry(24.0f, &quot;Red&quot;)); entries.add(new PieEntry(30.8f, &quot;Blue&quot;)); PieDataSet set = new PieDataSet(entries, &quot;Election Results&quot;); PieData data = new PieData(set); pieChart.setData(data); pieChart.invalidate(); // refresh PieEntry对象不能保存x位置的值，因为图表中显示的PieEntry对象的顺序由其在条目列表中的顺序确定。 添加一些额外的样式时，所得到的PieChart与上面使用的数据可能类似于：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Y轴（YAxis）]]></title>
    <url>%2F2017%2F08%2F09%2Fy%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[这YAxis是AxisBase的一个子类。这章只描述了YAxis，而不是它的超类AxisBase。 该YAxis类（比2.0.0更老版本的称呼为YLabels），是数据和一切与垂直轴相关的信息容器。每个Line-，Bar-，Scatter或CandleStickChart都有一个左YAxis对象和右YAxis对象，分别负责左轴或右轴。雷达图只有一个YAxis。默认情况下，图表的两个轴都被启用，并将被绘制。 为了获得一个实例中的YAxis类，请选择以下方法之一： YAxis leftAxis = chart.getAxisLeft(); YAxis rightAxis = chart.getAxisRight(); YAxis leftAxis = chart.getAxis(AxisDependency.LEFT); YAxis yAxis = radarChart.getYAxis(); //这个方法只有radarchart 在运行时，public AxisDependency getAxisDependency()用来确定该轴代表的图表的边。 在设置图表的数据之前，需要应用影响轴值范围的自定义。 轴依赖性默认情况下，添加到图表的所有数据都会在图表左侧YAxis绘制。如果没有进一步指定和启用，则右侧的值YAxis被调整为与左轴相同的刻度。 如果您的图表需要支持不同的轴刻度，则可以通过设置数据应该绘制的轴来实现。这可以通过改变AxisDependency来完成您的DataSet目标： LineDataSet dataSet = ... ; //获取一个数据集 dataSet.setAxisDependency(AxisDependency.RIGHT); 设置此项将更改您的数据绘制轴。 零线除了在每个值旁边起源的网格线之外，还有一个YAxis所谓的零滚动，它在轴上的零（0）值处绘制，并且与网格线类似，但可以单独配置。 setDrawZeroLine(boolean enabled)：启用/禁用绘制零线。 setZeroLineWidth(float width)：设置零行的行宽。 setZeroLineColor(int color)：设置零线应具有的颜色。 零线示例代码： //数据具有AxisDependency.LEFT YAxis left = mChart.getAxisLeft(); left.setDrawLabels(false); //无轴标签 left.setDrawAxisLine(false); //没有轴线 left.setDrawGridLines(false); //无网格线 left.setDrawZeroLine(true); //绘制零行 mChart.getAxisRight().setEnabled(false); //没有右轴 上述代码将导致zero-line如下图所示。不绘制轴值，不绘制网格线或轴线，仅只有zero-line。 更多示例代码YAxis yAxis = mChart.getAxisLeft(); yAxis.setTypeface（...）; //设置不同的字体 yAxis.setTextSize（12f）; //设置文字大小 yAxis.setAxisMinimum（0f）; //从零开始 yAxis.setAxisMaximum（100f）; //轴最大值为100 yAxis.setTextColor（颜色。 BLACK）; yAxis.setValueFormatter（new MyValueFormatter（））; yAxis.setGranularity（1f）; //间隔1 yAxis.setLabelCount（6，true）; //强制6个标签 // ...等等]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.X轴（XAxis）]]></title>
    <url>%2F2017%2F08%2F09%2Fx%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[XAxis是AxisBase的一个子类，它继承了许多样式和方便的方法。 XAxis类（在之前的2.0.0版本称为 XLabels），是用于一切有关水平轴的数据和信息的容器。每个Line-，Bar-，Scatter-，CandleStick-和RadarChart都有一个XAxis对象。 XAxis类允许特定的造型和由（可由）以下组分/部分组成： 所谓的“轴线”被直接绘制在标签上并与之平行 “网格线”，各自源于垂直方向的轴标签 为了获得一个实例中的XAxis类，请执行以下操作： XAxis xAxis = chart.getXAxis(); 自定义轴值 setLabelRotationAngle(float angle)：设置绘制x轴标签的角度（以度为单位）。 setPosition(XAxisPosition pos)：设置XAxis应显示的位置。在TOP，BOTTOM，BOTH_SIDED，TOP_INSIDE或BOTTOM_INSIDE之间进行选择。 示例代码 XAxis xAxis = chart.getXAxis(); xAxis.setPosition(XAxisPosition.BOTTOM); xAxis.setTextSize(10f); xAxis.setTextColor(Color.RED); xAxis.setDrawAxisLine(true); xAxis.setDrawGridLines(false); //设置一个自定义值格式化程序 xAxis.setValueFormatter(new MyCustomFormatter()); // and more…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.轴（AxisBase）]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%BD%B4%EF%BC%88AxisBase%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这个wiki页面的重点介绍AxisBase类，它是XAxis（X轴）和YAxis（Y轴）两者的基类，在v2.0.0中引入。 下面提到的以下方法可以应用于两个轴。 这个轴类允许特定的样式，包括（可以包括）以下组件/部件： 标签（以垂直（y轴）或水平（x轴）对齐绘制），其中包含轴描述值 所谓的“轴线”被直接绘制在标签上并与之平行 “网格线”，各自源自水平方向的轴标签 LimitLines允许提供特殊信息，如边界或约束 控制应绘制哪些零件（轴） setEnabled(boolean enabled)：设置轴启用或禁用。如果禁用，无论任何其他设置如何，都不会绘制轴的任何部分。 setDrawLabels(boolean enabled)：将其设置为true可以绘制轴的标签。 setDrawAxisLine(boolean enabled)：如果沿着轴（轴线）的线应该被绘制，则将其设置为true。 setDrawGridLines(boolean enabled)：将其设置为true可以绘制轴的网格线。 自定义轴范围（最小/最大） setAxisMaximum(float max)：设置此轴的自定义最大值。如果设置，此值将不会根据提供的数据自动计算。 resetAxisMaximum()：调用此命令来撤销先前设置的最大值。通过这样做，您将再次允许轴自动计算它的最大值。 setAxisMinimum(float min)：设置此轴的自定义最小值。如果设置，此值将不会根据提供的数据自动计算。 resetAxisMinimum()：调用此命令来撤消先前设置的最小值。通过这样做，您将再次允许轴自动计算它的最小值。 setStartAtZero(boolean enabled)：已弃用 - 使用setAxisMinValue(…)或setAxisMaxValue(…)替代。 setInverted(boolean enabled)：如果设置为true，则该轴将反转，这意味着最高值将在底部，最低值在顶部。 setSpaceTop(float percent)：与轴上的最高值相比，设置图表中最高值的顶部间距（以总轴范围的百分比表示）。 setSpaceBottom(float percent)：与轴上的最低值相比，设置图表中最低值的底部间距（以总轴范围的百分比表示）。 setShowOnlyMinMax(boolean enabled)：如果启用，该轴将仅显示其最小值和最大值。这将忽略/覆盖定义的标签计数（如果不强制）。 setLabelCount(int count, boolean force)：设置y轴的标签数量。请注意，这个数字是不固定的（如果强制== false），只能近似。如果强制启用（true），则绘制精确的指定标签计数 - 这可能导致轴上的数字不均匀。 setPosition(YAxisLabelPosition pos)：设置绘制轴标签的位置。INSIDE_CHART或OUTSIDE_CHART。 setGranularity(float gran)：设置y轴值之间的最小间隔。这可以用于在放大到为轴设置的小数位数不再允许区分两个轴值的点时避免重复值。 setGranularityEnabled(boolean enabled)：启用限制放大时y轴间隔的粒度特征。默认值：false 样式/修改轴 setTextColor(int color)：设置轴标签的颜色。 setTextSize(float size)：设置dp中轴标签的文本大小。 setTypeface(Typeface tf)：设置Typeface轴标签的自定义。 setGridColor(int color)：设置此轴的网格线的颜色。 setGridLineWidth(float width)：设置此轴的网格线的宽度。 setAxisLineColor(int color)：设置此轴的轴线的颜色。 setAxisLineWidth(float width)：设置此轴的轴线的宽度。 enableGridDashedLine(float lineLength, float spaceLength, float phase)：允许以虚线模式绘制网格线，例如像这样的“ - - - - - ”。“lineLength”控制线段的长度，“spaceLength”控制线间的空间，“phase”控制起点。 格式化轴值 对于格式化轴值，可以使用IAxisValueFormatter界面，它的介绍在这里。 您可以使用axis.setValueFormatter(IAxisValueFormatter formatter)方法将自定义格式化程序设置给轴。 限制线这两个轴支持所谓的LimitLines允许呈现特殊信息，如边界或约束。LimitLines添加到YAxis水平方向，并在垂直方向添加到XAxis。下边是您如何LimitLines从轴上添加和删​​除： addLimitLine(LimitLine l)：LimitLine向此轴添加新的。 removeLimitLine(LimitLine l)：LimitLine从该轴移除指定的。 更多添加/删除可用的方法。 setDrawLimitLinesBehindData(boolean enabled)：允许控制LimitLines和实际数据之间的z顺序。如果设置为true，则将LimitLines其拖放到实际数据之后，否则返回顶部。默认值：false 限制线（类LimitLine）（名称可能指示）可以使用简单线条为用户提供附加信息。 例如，您的图表可能会显示用户使用应用程序记录的各种血压测量结果。为了通知用户，超过140 mmHg的收缩压被认为是健康风险，您可以添加LimitLine140以提供该信息。 示例代码YAxis leftAxis = chart.getAxisLeft(); LimitLine ll = new LimitLine(140f, &quot;Critical Blood Pressure&quot;); ll.setLineColor(Color.RED); ll.setLineWidth(4f); ll.setTextColor(Color.BLACK); ll.setTextSize(12f); // .. and more styling options leftAxis.addLimitLine(ll);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.突出显示值]]></title>
    <url>%2F2017%2F08%2F08%2F%E7%AA%81%E5%87%BA%E6%98%BE%E7%A4%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[本节重点介绍基于版本v3.0.0，通过点击手势和编程方式突出显示图表中的条目的主题 启用/禁用突出显示 setHighlightPerDragEnabled(boolean enabled)：将其设置为true Chart，以便在完全缩小时在图表上拖动时突出显示。默认值：true setHighlightPerTapEnabled(boolean enabled)：将其设置为false，Chart以防止点击手势突出显示值。仍然可以通过拖动或以编程方式突出显示值。默认值：true setMaxHighlightDistance(float distanceDp)：设置dp中的最大高亮距离。图表上远离条目的图表距离不会触发高亮。默认值：500dp 除此之外，可以为单个DataSet对象配置突出显示： dataSet.setHighlightEnabled(true); //允许突出显示DataSet //将此设置为false可禁用高亮指示符（lines） dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator // and more ... 以编程方式突出显示 highlightValue(float x, int dataSetIndex, boolean callListener)：突出显示给定DataSet中给定x位置的值。提供-1作为dataSetIndex以撤消所有突出显示。布尔标志决定了应该调用选择侦听器。 highlightValue(Highlight high, boolean callListener)：突出显示提供的Highlight对象所代表的值。提供null以撤销所有突出显示。布尔标志决定了应该调用选择侦听器。 highlightValues(Highlight[] highs)：突出显示给定Highlight[]数组所表示的值。提供null或一个空数组来撤消所有突出显示。 getHighlighted()：返回一个Highlight[]数组，其中包含有关所有突出显示的条目及其x-index和dataset-index的信息。 选择回调该库在交互时提供了许多用于回调的侦听器。其中一个是OnChartValueSelectedListener通过触摸突出显示值时的回调： public interface OnChartValueSelectedListener { / ** *当在图表中选择了一个值时调用。 * * @param e所选条目。 * @param h相应的突出显示对象，其中包含关于突出显示位置的信息 * / public void onValueSelected（Entry e，Highlight h）; / ** *当没有选择任何东西或进行“未选择”时调用。 * / public void onNothingSelected（）; } 只需让你的应该接收回调的类实现这个接口并将其设置为监听器到图表： chart.setOnChartValueSelectedListener(this); 亮点类所述Highlight类表示与突出相关联的所有数据Entry，如突出显示的Entry对象本身，DataSet它属于，它的绘图表面更上的位置。它可以用于获取有关已经突出显示的信息Entry，或用于提供信息以Chart供Entry高亮显示。为此目的，Highlight该类提供了两个构造函数： /**标准亮点的构造函数* / public Highlight（ float x， int dataSetIndex）{ ... } /**堆叠BarEntry高亮度的构造函数* / public Highlight（ float x， int dataSetIndex， int stackIndex）{ ... } 这些构造函数可用于创建Highlight允许以编程方式执行突出显示的对象： //突出显示第一个（0）数据集中的条目和x位置50 Highlight highlight = new Highlight(50f, 0); chart.highlightValue(highlight, false); //突出显示此值，不要调用监听器 自定义荧光笔所有以高亮手势形式显示的用户输入都由默认ChartHighlighter类进行内部处理。使用以下方法可以使用自定义实现替换默认的highligher： setHighlighter(ChartHighlighter highlighter)：为处理/处理在图表视图中执行的所有突出显示触摸事件的图表设置自定义高亮对象。您的自定义荧光笔对象需要扩展ChartHighlighter类。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.与图表的互动]]></title>
    <url>%2F2017%2F08%2F08%2F%E4%B8%8E%E5%9B%BE%E8%A1%A8%E7%9A%84%E4%BA%92%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[该库允许您完全自定义与图表视图的触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用互动 setTouchEnabled(boolean enabled)：允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled)：启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled)：启用/禁用两个轴上图表的缩放。 setScaleXEnabled(boolean enabled)：启用/禁用x轴上的缩放。 setScaleYEnabled(boolean enabled)：启用/禁用y轴上的缩放。 setPinchZoom(boolean enabled)：如果设置为true，则可以使用缩小缩放。如果禁用，可以单独放大x轴和y轴。 setDoubleTapToZoomEnabled(boolean enabled)：将其设置为false可禁止通过双击来缩放图表。 图表闪烁/减速 setDragDecelerationEnabled(boolean enabled)：如果设置为true，图表在触摸后继续滚动。默认值：true。 setDragDecelerationFrictionCoef(float coef)：减速摩擦系数在[0; 1]间隔，较高的值表示速度将缓慢降低，例如，如果设置为0，它将立即停止。1是无效值，将自动转换为0.9999。 突出显示值突出显示部分将介绍如何通过点按手势和编程方式突出显示条目。 手势回调OnChartGestureListener将允许您对图表上的手势做出反应： public interface OnChartGestureListener { /** *当触摸手势在图表上开始时的回调（ACTION_DOWN） * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * 当触摸手势在图表上结束时的回调(ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * 当图表被长按时回调。 * * @param me */ public void onChartLongPressed(MotionEvent me); /** *图表双击时回调。 * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** *当图表单点击时回调。 * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * 在图表上做出一个简单的滑动时回调。 * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** *当图表通过缩放手势缩放/缩放时回调。 * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** *当图表通过拖动手势移动/翻转时回调。 * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY); } 只需让你的应该接收回调的类实现这个接口并将其设置为监听器到图表： chart.setOnChartGestureListener(this);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.入门]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本章介绍使用此库的基本设置。 添加依赖项作为第一步，将这个库的依赖项添加到您的项目中。在这个存储库的使用部分描述了如何做到这一点。Gradle是使用此库作为依赖关系的推荐方法。 创建视图 对于使用a LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在.xml中定义它： &lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后从你的Activity，Fragment或其它布局检索： // 在这个例子当中 LineChart 是在 xml重初始化的 LineChart chart = (LineChart) findViewById(R.id.chart); 或者在代码中创建它（然后将其添加到布局）： //以编程方式创建一个LineChart LineChart chart = new LineChart(Context); //取得在XML定义的布局 RelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout); rl.add(chart); //添加以编程方式创建的图表 添加数据拥有图表实例后，您可以创建数据并将其添加到图表中。此示例使用LineChart类，其中Entry表示图表中具有x和y坐标的单个条目。其他图表类型，例如BarChart使用其他类（例如BarEntry）。 要将数据添加到图表中，应将每个数据对象包含到Entry对象中，如下所示： YourData[] dataObjects = ...; List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;(); for (YourData data : dataObjects) { //将您的数据转换为Entry对象 entries.add(new Entry(data.getValueX(), data.getValueY())); } 作为下一步，您需要将你创建的List对象添加到一个LineDataSet对象。DataSet对象持有属于一类的数据，并允许对该数据进行单独样式。如果启用，下面使用的“标签”只有一个描述性的目的，并显示在Legend中。 LineDataSet dataSet = new LineDataSet（entries，“ Label ”）; //添加条目到数据集 dataSet.setColor（...）; dataSet.setValueTextColor（...）; //造型，... 作为最后一步，您需要将创建的LineDataSet对象添加到LineData对象。该对象包含由Chart实例表示的所有数据，并允许进一步的设置样式。创建数据对象后，可以将其设置给图表并刷新： LineData lineData = new LineData(dataSet); chart.setData(lineData); chart.invalidate(); // refresh 上述情况只是一个非常基本的设置。有关更详细的说明，请参阅设置数据部分，其中介绍了根据示例如何将数据添加到各种类型Chart。 造型有关图表和数据的设置和样式的信息，请访问常规设置和样式部分。关于个别图表类型的更具体的样式和设置，请查看具体设置和样式 wiki页面。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPAndroidChart库的viki翻译]]></title>
    <url>%2F2017%2F08%2F06%2FMPAndroidChart%E6%96%87%E6%A1%A3%E7%9A%84viki%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[欢迎使用MPAndroidChart库的文档。 文档章节 入门 与图表的相互作用 突出显示值 轴（AxisBase） XAxis YAxis 设置数据 设置颜色 格式化数据值（ValueFormatter） 格式化轴值（AxisValueFormatter） 一般设置和样式 具体设置和样式 传说 动态和实时数据 修改视口 动画 MarkerView（Popup View） ChartData类 ChartData子类 DataSet类（一般的DataSet样式） DataSet子类（特定DataSet样式） ViewPortHandler 定制填充线位置（FillFormatter） 保镖 Realm.io手机数据库 创建自己的（自定义）DataSet 其他（更有用的东西） 其他信息 使用此库的项目（参考） 性能]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Accessibility(辅助功能)学习]]></title>
    <url>%2F2017%2F05%2F10%2FAndroid-Accessibility-%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[写在前面前一段项目的需要（需要自动开启微信并自动添加通讯录好友以及发朋友圈）接触了关于AccessibilityService(辅助功能)的开发。刚开始的时候根本没有想到可以用辅助功能来帮助实现这个需求，一直在研究屏幕监听和模拟点击功能，因为手机没有root屏幕监听和模拟点击功能不可以用，后来通过和同事讨论，发现可以使用辅助功能来实现这一需求。Accessibility主要目的是帮助一些因为有视觉，听觉，身体障碍而无法完全使用触摸屏或铃声等的用户来使用Android的。而实际上现在很多开发者都用它来实现一些其他功能了，比如说微信抢红包，自动安装APK，强制停止应用等。那么接下来开始介绍这个AccessibilityService（辅助功能）: AccessibilityService的使用 AccessibilityService是Service的子类，运行在后台,并且能够收到由系统发出的一些事件(AccessibilityEvent,这些事件表示用户界面一系列的状态变化),比如焦点改变,输入内容变化,按钮被点击了等等,该种服务能够请求获取当前活动窗口并查找其中的内容.换言之,界面中产生的任何变化都会产生一个时间,并由系统通知给AccessibilityService.这就像监视器监视着界面的一举一动,一旦界面发生变化,立刻发出警报. 创建自己的服务类创建自己的服务类,需要继承AccessibilityService类。 需要重载以下方法： onServiceConnected() 系统会在成功连接上你的服务的时候调用这个方法，在这个方法里你可以做一下初始化工作，例如设备的声音震动管理，也可以调用setServiceInfo()进行配置工作。 onAccessibilityEvent() 通过这个函数可以接收系统发送来的AccessibilityEvent，接收来的AccessibilityEvent是经过过滤的，过滤是在配置工作时设置的。 onInterrupt() 这个在系统想要中断AccessibilityService返给的响应时会调用。在整个生命周期里会被调用多次。 onUnbind(Intent intent) 在系统将要关闭这个AccessibilityService会被调用。在这个方法中进行一些释放资源的工作 声明和其它Service服务一样，需要在AndroidManifest.xml声明，而且还要做以下两件事： 指定intent-filter为 “android.accessibilityservice.AccessibilityService” 添加 BIND_ACCESSIBILITY_SERVICE权限，确保只有系统可以绑定到它** 如果项目中缺少任意一个，系统会忽略AccessibilityService。下面是一个声明例子： &lt;service android:name=&quot;.MyAccessibilityService&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; . . . &lt;/service&gt; 参数配置AccessibilityService可以配置用来接收特定类型的事件，只监听特定的packages，在特定的时间内只能获得每种事件只有一次，检索窗口内容,指定一个设置活动,等等 配置AccessibilityService有两种方法: 在声明服务时，在AndroidManifest.xml中提供一个meta-data。下面给出了一个带有meta-data的服务声明: &lt;service android:name=&quot;.MyAccessibilityService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessibilityservice&quot; /&gt; &lt;/service&gt; accessibility.xml的相关配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeAllMask&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:accessibilityFlags=&quot;flagDefault&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/accessibility_service_description&quot; android:notificationTimeout=&quot;100&quot; android:packageNames=&quot;com.tencent.mm,com.yulong.android.launcherL&quot; /&gt; 注意：此方法使设置的所有属性。欲了解更多详情，请参阅 SERVICE_META_DATA和accessibility-service。 调用setServiceInfo(AccessibilityServiceInfo)。注意，此方法可以任何时候调用来动态地更改AccessibilityService的配置。 @Override protected void onServiceConnected() { AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo(); serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK; serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC; serviceInfo.packageNames = new String[]{&quot;com.tencent.mm,com.yulong.android.launcherL&quot;}; serviceInfo.notificationTimeout=100; setServiceInfo(serviceInfo); } 注意：这种方法只可以设置动态配置属性：eventTypes，feedbackType，flags，notificationTimeout，packageNames; 欲了解更多详情，请参阅AccessibilityServiceInfo。 现在我们对配置中的重要属性进行说明: accessibilityEventTypes: 表示接收事件的类型： 方法 说明 AccessibilityEvent.TYPES_ALL_MASK 全局事件响应 AccessibilityEvent.TYPE_VIEW_CLICKED 点击事件 accessibilityFeedbackType:表示反馈方式: 方法 说明 AccessibilityServiceInfo.FEEDBACK_GENERIC 通用的反馈 AccessibilityServiceInfo.FEEDBACK_AUDIBLE 声音反馈 canRetrieveWindowContent: 表示该服务能否访问活动窗口中的内容.如果在服务中获取窗体内容的化,则需要设置其值为true. notificationTimeout: 接受事件的时间间隔,通常将其设置为100. packageNames: 表示对该服务是用来监听哪个包的产生的事件,中间可以用&quot;,&quot;分隔开。 监听指定类型事件监听AccessibilityEvent事件我们在onAccessibilityEvent(AccessibilityEvent event)方法中进行： @Override public void onAccessibilityEvent(AccessibilityEvent event) { int eventType = event.getEventType(); switch (eventType) { case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED: //通知栏消息 break; case AccessibilityEvent.TYPE_VIEW_CLICKED: //界面点击 break; //....... } } 这个事件类型很多的，我们可以查看AccessibilityEvent类的源码： @Deprecated public static final int MAX_TEXT_LENGTH = 500; /** * Represents the event of clicking on a {@link android.view.View} like * {@link android.widget.Button}, {@link android.widget.CompoundButton}, etc. */ public static final int TYPE_VIEW_CLICKED = 0x00000001; /** * Represents the event of long clicking on a {@link android.view.View} like * {@link android.widget.Button}, {@link android.widget.CompoundButton}, etc. */ public static final int TYPE_VIEW_LONG_CLICKED = 0x00000002; /** * Represents the event of selecting an item usually in the context of an * {@link android.widget.AdapterView}. */ public static final int TYPE_VIEW_SELECTED = 0x00000004; /** * Represents the event of setting input focus of a {@link android.view.View}. */ public static final int TYPE_VIEW_FOCUSED = 0x00000008; /** * Represents the event of changing the text of an {@link android.widget.EditText}. */ public static final int TYPE_VIEW_TEXT_CHANGED = 0x00000010; /** * Represents the event of opening a {@link android.widget.PopupWindow}, * {@link android.view.Menu}, {@link android.app.Dialog}, etc. */ public static final int TYPE_WINDOW_STATE_CHANGED = 0x00000020; /** * Represents the event showing a {@link android.app.Notification}. */ public static final int TYPE_NOTIFICATION_STATE_CHANGED = 0x00000040; /** * Represents the event of a hover enter over a {@link android.view.View}. */ public static final int TYPE_VIEW_HOVER_ENTER = 0x00000080; /** * Represents the event of a hover exit over a {@link android.view.View}. */ public static final int TYPE_VIEW_HOVER_EXIT = 0x00000100; /** * Represents the event of starting a touch exploration gesture. */ public static final int TYPE_TOUCH_EXPLORATION_GESTURE_START = 0x00000200; /** * Represents the event of ending a touch exploration gesture. */ public static final int TYPE_TOUCH_EXPLORATION_GESTURE_END = 0x00000400; /** * Represents the event of changing the content of a window and more * specifically the sub-tree rooted at the event&apos;s source. */ public static final int TYPE_WINDOW_CONTENT_CHANGED = 0x00000800; /** * Represents the event of scrolling a view. */ public static final int TYPE_VIEW_SCROLLED = 0x00001000; /** * Represents the event of changing the selection in an {@link android.widget.EditText}. */ public static final int TYPE_VIEW_TEXT_SELECTION_CHANGED = 0x00002000; /** * Represents the event of an application making an announcement. */ public static final int TYPE_ANNOUNCEMENT = 0x00004000; /** * Represents the event of gaining accessibility focus. */ public static final int TYPE_VIEW_ACCESSIBILITY_FOCUSED = 0x00008000; /** * Represents the event of clearing accessibility focus. */ public static final int TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED = 0x00010000; /** * Represents the event of traversing the text of a view at a given movement granularity. */ public static final int TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY = 0x00020000; /** * Represents the event of beginning gesture detection. */ public static final int TYPE_GESTURE_DETECTION_START = 0x00040000; /** * Represents the event of ending gesture detection. */ public static final int TYPE_GESTURE_DETECTION_END = 0x00080000; /** * Represents the event of the user starting to touch the screen. */ public static final int TYPE_TOUCH_INTERACTION_START = 0x00100000; /** * Represents the event of the user ending to touch the screen. */ public static final int TYPE_TOUCH_INTERACTION_END = 0x00200000; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The type of change is not defined. */ public static final int CONTENT_CHANGE_TYPE_UNDEFINED = 0x00000000; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * A node in the subtree rooted at the source node was added or removed. */ public static final int CONTENT_CHANGE_TYPE_SUBTREE = 0x00000001; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The node&apos;s text changed. */ public static final int CONTENT_CHANGE_TYPE_TEXT = 0x00000002; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The node&apos;s content description changed. */ public static final int CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION = 0x00000004; 查找节点View系统提供了两个方法让我们来进行查找想要的节点View： 通过节点View的Text内容来查找：findAccessibilityNodeInfosByText(“查找内容”)这种方式查找，就是像TextView,Button等View有文本内容的，可以使用这种方式快速的找到。 nodes = getRootInActiveWindow().findAccessibilityNodeInfosByText(&quot;手机联系人&quot;); if (nodes != null &amp;&amp; nodes.size() &gt; 0) { AccessibilityNodeInfo node = nodes.get(0).getParent(); node.performAction(AccessibilityNodeInfo.ACTION_CLICK); } 第二种是通过节点View在xml布局中的id名称来查找：findAccessibilityNodeInfosByViewId(“@id/xxx”)；(关于怎样找到View在xml布局中的id我下面有说明) nodes = getRootInActiveWindow().findAccessibilityNodeInfosByViewId(&quot;com.tencent.mm:id/f_&quot;); if (nodes != null &amp;&amp; nodes.size() &gt; 0) { for (int i = 0; i &lt; nodes.size(); i++) { node = nodes.get(i).getParent(); node.performAction(AccessibilityNodeInfo.ACTION_CLICK); } } 模拟点击指定事件我们找到我们想要的View节点，调用方法模拟事件： 调用performAction(AccessibilityNodeInfo.ACTION_CLICK)这个方法即可 当然这里的参数就是指定事件的名称，这个和AccessibilityEvent中监听的那些事件是一一对应的，这里是模拟点击事件，我们当然可以模拟View的滚动事件，长按事件等。 实际应用——微信抢红包插件上面我们就介绍了一个辅助功能开发的具体步骤，那么下面就通过一个简单的例子，来实战一下：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Accessibility</tag>
        <tag>辅助功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[底部导航栏凸起效果]]></title>
    <url>%2F2017%2F03%2F15%2FAndroid%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%87%B8%E8%B5%B7%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[先上效果图 此底部导航栏的布局很简单，其中用到的最主要的就是在突出布局的父布局设置android:clipChildren为false即可，默认为true，android:clipChildren的意思：是否限制子View在其范围内，然后设置突出布局android:layout_gravity=”bottom”就可以了 最后贴出代码，使用RadioGroup+RadioButton实现的底部导航 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clipChildren=&quot;false&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewPager android:id=&quot;@+id/vp_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/ViewPager&gt; &lt;View android:id=&quot;@+id/div_view&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1.0px&quot; android:background=&quot;#d9d9d9&quot; /&gt; &lt;RadioGroup android:id=&quot;@+id/rg_group&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;@color/apTabBackground&quot; android:clipChildren=&quot;false&quot; android:elevation=&quot;8dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:id=&quot;@+id/first&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:checked=&quot;true&quot; android:drawableTop=&quot;@drawable/first_selector&quot; android:text=&quot;首页&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/second&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/second_selector&quot; android:text=&quot;学堂&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/third&quot; style=&quot;@style/Bottom_Tab_Style1&quot; android:layout_gravity=&quot;bottom&quot; android:clipChildren=&quot;false&quot; android:drawableBottom=&quot;@drawable/third_selector&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/fourth&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/fourth_selector&quot; android:text=&quot;互动&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/fifth&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/fifth_selector&quot; android:text=&quot;我&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，技术博客]]></title>
    <url>%2F2017%2F03%2F08%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。第一次写博客，请多多关照]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>