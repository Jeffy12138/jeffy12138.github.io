<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[14.动态和实时数据]]></title>
    <url>%2F2017%2F08%2F14%2F%E5%8A%A8%E6%80%81%E5%92%8C%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[自v1.6.3起可用 - 不断改进。 为了将新数据添加到图表或动态删除数据，有多种方法可以将Entry对象从现有对象DataSet添加或删除或从现有ChartData对象添加或删除DataSet对象。 动态添加/删除数据的可能性Class DataSet（和所有子类）： addEntry(Entry e)：将给定的Entry对象添加到DataSet。 Class ChartData（和所有子类）： addEntry(Entry e, int dataSetIndex)：将给定的数据集添加Entry到DataSet指定的数据集索引。 addDataSet(DataSet d)：将给定DataSet对象添加到ChartData对象。 除此之外，还有动态删除数据的方法： Class DataSet（和所有子类）： public boolean removeFirst()：从条目数组中删除此DataSet的第一个条目（在索引0）。如果成功则返回true，否则返回false。 public boolean removeLast()：从条目数组中删除此DataSet的最后一个条目（索引大小为-1）。如果成功则返回true，否则返回false。 public boolean removeEntry(Entry e)：Entry从中删除给定的对象DataSet。成功返回true。 public boolean removeEntry(int xIndex)：Entry从给定的x-index中删除DataSet。成功返回true。Class ChartData（和所有子类）： public boolean removeEntry(Entry e, int dataSetIndex)：Entry从DataSet给定的数据集索引中删除给定的对象。成功返回true。 public boolean removeEntry(int xIndex, int dataSetIndex)：Entry从DataSet给定的数据集索引中删除给定的x- index。成功返回true。 public boolean removeDataSet(DataSet d)：DataSet从ChartData对象中删除给定的对象。成功返回true。 public boolean removeDataSet(int index)：DataSet从ChartData对象中删除给定的索引。成功返回true。 记住在动态添加或删除数据后，notifyDataSetChanged() 必须在刷新之前调用。 //示例1 //将条目添加到“data”对象 exampleData.addEntry(...); chart.notifyDataSetChanged(); //让图表知道它是数据变化的 chart.invalidate(); //刷新 //实施例2 //条目添加到“数据集”对象 dataSet.addEntry(...); exampleData.notifyDataChanged(); //让数据知道一个dataSet更改的 chart.notifyDataSetChanged(); //让图表知道它是数据变化的 chart.invalidate(); //刷新 注意：方法moveViewTo(…)会自动调用invalidate()。 动态数据示例有关如何实现动态数据添加/删除的示例，请参考示例应用程序和以下示例Activities： DynamicalAddingActivity RealtimeDataActivity]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15.修改视口]]></title>
    <url>%2F2017%2F08%2F14%2F%E4%BF%AE%E6%94%B9%E8%A7%86%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[该库具有各种修改视口的方法（图表上可见，视图的目的）。请注意，这些方法只适用的LineChart，BarChart，ScatterChart和CandleStickChart。 下面提到的方法由Chart课程提供。修改视口的另一种方法是通过ViewPortHandler直接访问它（没有图表提供的内部安全性）。这仅适用于熟悉API的高级用户。 请注意，修改视口的所有方法需要在Chart 设置数据后调用。 限制可见的内容 setVisibleXRangeMaximum(float maxXRange)：设置应该是最大可见的区域的大小（x轴上的范围）。如果这样设置为10，则可以立即查看x轴上不超过10个值，而不滚动。 setVisibleXRangeMinimum(float minXRange)：设置应该是最小可见的区域的大小（x轴上的范围）。如果这样设置为10，则不能在x轴上进一步放大超过10个值。 setVisibleYRangeMaximum(float maxYRange, AxisDependency axis)：设置应该是最大可见的区域的大小（y轴上的范围）。您还需要提供此约束应适用的轴。 setViewPortOffsets(float left, float top, float right, float bottom)：设置当前ViewPort的自定义偏移量（实际图表窗口两侧的偏移量）。设置此操作将阻止图表自动计算其偏移量。使用resetViewPortOffsets()撤消此。仅当您知道您所做的操作时才使用此功能。 resetViewPortOffsets()：重置通过setViewPortOffsets(…)方法设置的所有自定义偏移量。允许图表再次自动计算所有偏移量。 setExtraOffsets(float left, float top, float right, float bottom)：设置要附加到自动计算的偏移量的附加偏移量（图表视图周围）。这不会改变自动计算的偏移量，而是增加了额外的空间。 移动视图（目标位置） fitScreen()：重置所有缩放和拖动，并使图表完全符合其边界（完全缩小）。 moveViewToX(float xValue)：将当前视口的左侧（边）移动到指定的x值。 moveViewToY(float yValue, AxisDependency axis)：将视口集中在提供的y轴上的指定y值（左侧或右侧）。 moveViewTo(float xValue, float yValue, AxisDependency axis)：这将使当前视口的左侧移动到x轴上的指定x值，并将视口居中到所提供的y轴上的指定y值（setVisibleXRange(…)与此相关联setVisibleYRange(…)。 centerViewTo(float xValue, float yValue, AxisDependency axis)：这将当前视口的中心移动到指定的x值和y值（使得组合意义与setVisibleXRange(…)和setVisibleYRange(…)。 用动画移动视图 ## （自版本v2.2.3起） moveViewToAnimated(float xValue, float yValue, AxisDependency axis, long duration)：这将将当前视口的左侧移动到x轴上的指定x值，并将视口以动画方式居中在提供的y轴上的指定y值。 centerViewToAnimated(float xValue, float yValue, AxisDependency axis, long duration)：这将以动画的方式将当前视口的中心移动到指定的x值和y值（根据轴）。 注意：所有moveViewTo(…)方法将自动 invalidate()（刷新）图表。没有必要进一步呼叫invalidate()。 缩放（以编程方式） zoomIn()：放大1.4f，进入图表中心。 zoomOut()：从图表中心缩小0.7f。 zoom(float scaleX, float scaleY, float x, float y)：放大或缩小给定的比例因子。x和y是缩放中心的坐标（以像素为单位）。记住1f =无缩放比例。 zoom(float scaleX, float scaleY, float xValue, float yValue, AxisDependency axis)：放大或缩小给定的比例因子。xValue和yValue是缩放中心的实际数据值（而不是像素）。记住1f =无缩放比例。 缩放动画 ## （自版本v2.2.3起） zoomAndCenterAnimated(float scaleX, float scaleY, float xValue, float yValue, AxisDependency axis, long duration)：以指定的比例因子缩放，并以动画方式将视口中心到指定轴上的指定值。 完整的例子 chart.setData(…); //首先设置数据 //现在修改视口 chart.setVisibleXRangeMaximum(20); //允许在x轴上同时显示20个值，而不是更多的 chart.moveViewToX(10);//将图表的左边缘设为x-index 10 // moveViewToX（…）也调用invalidate（）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13.Legend]]></title>
    <url>%2F2017%2F08%2F14%2FLegend%2F</url>
    <content type="text"><![CDATA[默认情况下，所有图表类型都支持图例，并在为图表设置数据后自动生成和绘制图例。Legend通常由通过一个标签的形式/形状表示多个条目的每一个。 自动生成的图例包含的条目数取决于不同颜色（跨所有DataSet对象）以及DataSet标签的数量。标签Legend取决于为DataSet图表中的已使用对象设置的标签。如果没有DataSet指定对象的标签，图表将自动生成。如果使用多种颜色DataSet，那么这些颜色是分组的，只能由（属于）一个标签描述。 对于自定义Legend，您可以Legend使用以下getLegend()方法从图表中检索对象： Legend legend = chart.getLegend(); 控制是否绘制图例 setEnabled(boolean enabled)：设置Legend启用或禁用。如果禁用，Legend将不会被绘制。 造型/修改图例 setTextColor(int color)：设置图例标签的颜色。 setTextSize(float size)：设置dp中图例标签的文本大小。 setTypeface(Typeface tf)：设置Typeface图例标签的自定义。 包装/剪裁避免 setWordWrapEnabled(boolean enabled)：如果启用，图例的内容将不会剪辑在图表边界之外，而是创建一个新行。请注意，这降低了性能，仅适用于图表下方的图例。 setMaxSizePercent(float maxSize)：以百分比形式设置整个图表视图中的最大相对大小。默认值：0.95f（95％） 自定义图例 setPosition(LegendPosition pos)：设置LegendPosition它Legend应该出现的位置。选择RIGHT_OF_CHART，RIGHT_OF_CHART_CENTER，RIGHT_OF_CHART_INSIDE，BELOW_CHART_LEFT，BELOW_CHART_RIGHT，BELOW_CHART_CENTER或PIECHART_CENTER（PieChart仅），…等等。 setForm(LegendForm shape)：设置LegendForm应该使用的。这是绘制在图例标签旁边的形状，DataSet其图例条目的颜色表示。在SQUARE，CIRCLE或LINE之间进行选择。 setFormSize(float size)：设置dp中的图例形式的大小。 setXEntrySpace(float space)：设置横轴上图例项之间的空格。 setYEntrySpace(float space)：设置纵轴上的图例项之间的空格。 setFormToTextSpace(float space)：设置图例标签和相应图例形式之间的空格。 setWordWrapEnabled(boolean enabled)传说中的文字是否包裹？/目前仅支持BelowChartLeft，BelowChartRight，BelowChartCenter支持。/你可能希望在换行时设置maxSizePercent，以设置文本包装的点。 设置自定义标签和颜色 setCustom(int[] colors, String[] labels)：设置自定义图例的标签和颜色数组。颜色计数应符合标签计数。每种颜色均为相同索引绘制的形状。空标签将启动一个组。A（-2）颜色将避免绘制表单这将禁用从数据集自动计算图例标签和颜色的功能。呼叫resetCustom()重新启用自动计算（然后notifyDataSetChanged()需要再次自动计算图例） resetCustom()：调用此功能将禁用自定义图例标签（由设置setCustom(…)）。相反，标签将再次自动计算（notifyDataSetChanged()调用后）。 setExtra(int[] colors, String[] labels)：设置在计算图例后将附加到自动计算颜色和标签数组末尾的颜色和标签。（如果已经计算了图例，则需要调用notifyDataSetChanged()以使更改生效） 例 Legend l = chart.getLegend(); l.setFormSize(10f); // 设置图例的形状/形状 l.setForm(LegendForm.CIRCLE); // 设置什么类型的形式/形状应该使用 l.setPosition(LegendPosition.BELOW_CHART_LEFT); l.setTypeface(…); l.setTextSize(12f); l.setTextColor(Color.BLACK); l.setXEntrySpace(5f); // 设置x轴上的图例项之间的空格 l.setYEntrySpace(5f); // 设置y轴上图例项之间的空格 // 设置自定义标签和颜色 l.setCustom(ColorTemplate.VORDIPLOM_COLORS, new String[] { “Set1”, “Set2”, “Set3”, “Set4”, “Set5” }); // and many more…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12.具体设置和样式]]></title>
    <url>%2F2017%2F08%2F13%2F%E5%85%B7%E4%BD%93%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在第1章中提到了适用于所有图表类型的入门常规图表设置和样式方法。本章重点介绍各种图表类型的具体设置。 Line-，Bar-，Scatter-，Candle-＆BubbleChart setAutoScaleMinMaxEnabled(boolean enabled)：表示是否启用了y轴自动缩放的标志。如果启用，只要视口更改，y轴就会自动调整到当前x轴范围的最小和最大y值。这对于显示财务数据的图表尤其有用。默认值：false setKeepPositionOnRotation(boolean enabled)：在更改方向后，图表应保持其位置（缩放/滚动）。默认值：false BarChart setDrawValueAboveBar(boolean enabled)：如果设置为true，则所有值都将绘制在其上方，而不是其顶部。 setDrawBarShadow(boolean enabled)：如果设置为true，则每个栏后面会绘制一个灰色区域，表示最大值。使他的业绩将降低约40％。 setDrawValuesForWholeStack(boolean enabled)：如果设置为true，则堆叠条的所有值都是单独绘制的，而不仅仅是它们的总和。 setDrawHighlightArrow(boolean enabled)：将其设置为true以在突出显示时绘制每个栏上方的突出显示箭头。 PieChart setDrawSliceText(boolean enabled)：将其设置为true可将x值文本绘制到饼图中。 setUsePercentValues(boolean enabled)：如果启用，则图表中的值以百分比绘制，而不是以原始值绘制。ValueFormatter然后以百分比形式提供为格式提供的值。 setCenterText(SpannableString text)：设置在PieChart中心绘制的文本。较长的文本将自动“包装”，以避免剪切到饼图。 setCenterTextRadiusPercent(float percent)：设置中心文本边界框的矩形半径，以百分比孔默认为1.f（100％）。 setHoleRadius(float percent)：将饼图中心的半径设置为最大半径的百分比（最大=整个图表的半径），默认为50％ setTransparentCircleRadius(float percent)：设置饼形图旁边的透明圆的半径，最大半径的百分比（max =整个图表的半径），默认值55％ - &gt;表示比中心孔大5％默认 setTransparentCircleColor(int color)：设置透明圆的颜色。 setTransparentCircleAlpha(int alpha)：设置透明圆应具有的透明度（0-255）。 setMaxAngle(float maxangle)：设置用于计算饼形圆的最大角度。360f意味着它是一个完整的PieChart，180f结果是一个半饼图。默认值：360f RadarChart setSkipWebLineCount(int count)：允许跳过来自图表中心的网页。特别有用，如果有很多行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.一般设置和样式]]></title>
    <url>%2F2017%2F08%2F13%2F%E4%B8%80%E8%88%AC%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本节重点介绍此库适用于所有Chart类型的的设置和样式。 刷新invalidate()：在图表上调用此方法将刷新（重绘）。这是为了使在图表上执行的更改生效而需要的。notifyDataSetChanged()：让图表知道底层数据已经改变，并执行所有必要的重新计算（偏移，图例，最大值，最小值，…）。特别是在动态添加数据时尤其如此。 记录setLogEnabled(boolean enabled)：将其设置为true将激活图表logcat输出。启用此功能对于性能不利，如果不需要，请保持禁用。一般图表样式 以下是您可以直接在图表上使用的一些一般样式方法： setBackgroundColor(int color)：设置覆盖整个图表视图的背景颜色。另外，.xml在布局文件中可以设置背景颜色。 setDescription(String desc)：设置出现在图表右下角的描述文字。 setDescriptionColor(int color)：设置说明文字的颜色。 setDescriptionPosition(float x, float y)：设置屏幕上描述文本的自定义位置（以像素为单位）。 setDescriptionTypeface(Typeface t)：设置Typeface用于绘制描述文本的用法。 setDescriptionTextSize(float size)：设置描述文本的大小，以像素为单位，最小6f，最大16f。 setNoDataText(String text)：设置图表为空时应显示的文本。 setDrawGridBackground(boolean enabled)：如果启用，将绘制图表绘图区域后面的背景矩形。 setGridBackgroundColor(int color)：设置网格背景应绘制的颜色。 setDrawBorders(boolean enabled)：启用/禁用绘制图表边框（图表周围的线）。 setBorderColor(int color)：设置图表边框线的颜色。 setBorderWidth(float width)：设置dp中图表边界线的宽度。 setMaxVisibleValueCount(int count)：设置图表上最大可见绘制值标签的数量。setDrawValues()启用后才会生效。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.格式化轴值（AxisValueFormatter）]]></title>
    <url>%2F2017%2F08%2F13%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%B4%E5%80%BC%EF%BC%88AxisValueFormatter%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在版本v3.0.0中引入，此界面允许在绘制之前自定义样式XAxis和YAxis值。 创建格式化程序所有需要对轴进行自定义格式化的值都是创建一个实现IAxisValueFormatter接口的类，如下所示。该格式器用于始终将轴的值格式化为1位十进制数字。 public class MyYAxisValueFormatter implements IAxisValueFormatter { private DecimalFormat mFormat; public MyAxisValueFormatter() { //格式值为1位十进制数 mFormat = new DecimalFormat(&quot;###,###,##0.0&quot;); } @Override public String getFormattedValue(float value, AxisBase axis) { // “value”表示标签在轴上的位置（x或y） return mFormat.format(value) + &quot; $&quot;; } /** 只有返回数字时才需要这个，否则返回0 */ @Override public int getDecimalDigits() { return 1; } } 下面的示例显示了如何将String[]数组绘制到轴上： public class MyXAxisValueFormatter implements IAxisValueFormatter { private String[] mValues; public MyXAxisValueFormatter(String[] values) { this.mValues = values; } @Override public String getFormattedValue(float value, AxisBase axis) { // “value”表示标签在轴上的位置（x或y） return mValues[(int) value]; } /** 只有返回数字时才需要这个，否则返回0 */ @Override public int getDecimalDigits() { return 0; } } 设置格式器在格式化程序创建之后，只需将其设置为您选择的轴： YAxis left = chart.getAxisLeft(); left.setValueFormatter(new MyYAxisValueFormatter()); String[] values = new String[] { ... }; XAxis xAxis = chart.getXAxis(); xAxis.setValueFormatter(new MyXAxisValueFormatter(values)); 而不是从轴最小值到轴最大值的默认值，轴现在将绘制格式化程序指定的数据。 限制间隔如果您使用基于数组索引的格式化程序（如上所述），将轴的最小间隔限制为“1”是有意义的： axis.setGranularity(1f); //将间隔限制为1（最小） 这将防止格式化程序绘制重复的轴标签（由轴间隔&lt;1）引起。只要图表的“缩放级别”足够高，它将停止重新计算更小的间隔。 预定格式化器 LargeValueFormatter：可用于格式化大值&gt;“1.000”。将“1.000”的值变为“1k”，“1.000.000”将为“1m”（百万），“1.000.000.000”为“1b”（十亿），像万亿的值将为“1t ”。 PercentFormatter：用于在每个值与1位十进制数字之后显示“％”号。特别有用的PieChart。50 - &gt; 50.0％ 示例格式化器 DayAxisValueFormatter：此格式化程序将提供的值转换为日期String，根据比例改变字符串。传统格式机 发布V3.0.0之前，有单独的格式化XAxis和YAxis。这些格式化程序的文档可以在这里找到： XAxisValueFormatter YAxisValueFormatter]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.格式化数据值（ValueFormatter）]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E6%8D%AE%E5%80%BC%EF%BC%88ValueFormatter%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自v1.6.2起可用 - 在v2.1.4中更改（改进） 该IValueFormatter可用于创建自定义界面的格式化程序类，允许DataSets在绘制图形之前以特定方式格式化图表中的值（从）。 对于使用IValueFormatter，只需创建一个新类，并让它实现接口并返回任何你想要显示的getFormattedValue(…)方法。 Creating a Formatterpublic class MyValueFormatter implements IValueFormatter { private DecimalFormat mFormat; public MyValueFormatter() { mFormat = new DecimalFormat(&quot;###,###,##0.0&quot;); // 使用一个小数 } @Override public String getFormattedValue(float value, Entry entry, int dataSetIndex, ViewPortHandler viewPortHandler) { //在这里写你的逻辑 return mFormat.format(value) + &quot; $&quot;; //例如附加一个美元符号 } } 然后，将您的格式化器设置给ChartData或DataSet对象： //对整个数据对象使用 lineData.setValueFormatter（ new MyValueFormatter（））; //对个别数据集对象使用 lineDataSet.setValueFormatter（ new MyValueFormatter（））; Predefined Formatters LargeValueFormatter：可用于格式化大值&gt;“1.000”。将“1.000”的值变为“1k”，“1.000.000”将为“1m”（百万），“1.000.000.000”为“1b”（十亿），像万亿的值将为“1t ”。 PercentFormatter：用于在每个值与1位十进制数字之后显示“％”号。特别有用的PieChart。50 - &gt; 50.0％ StackedValueFormatter：专门设计用于堆叠的格式化程序BarChart。它允许指定是否应绘制所有堆栈值或仅指定最大值。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.设置颜色]]></title>
    <url>%2F2017%2F08%2F12%2F%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[自版本v1.4.0以来，ColorTemplate不再是需要负责在以前版本中设置颜色的对象。然而，它仍然保留所有预定义的颜色阵列（例如，ColorTemplate.VORDIPLOM_COLORS并提供将颜色从资源（资源整数）转换为“真实”颜色的便利方法。 而取代ColorTemplate，现在可以直接通过DataSet对象指定颜色，这允许为每个DataSet对象分别设计样式。 在这个简短的例子中，我们有两个不同的LineDataSet对象代表了两家公司的季度收入（以前在“ 设置数据”教程中提到），我们现在要设置不同的颜色。 我们想要什么 “公司1”的值应由颜色“红色”的四种不同变体表示“公司2”的值应由颜色“绿色”的四种不同变体表示这是代码如下所示： LineDataSet setComp1 = new LineDataSet（valsComp1，“ Company 1 ”）; //为数据集设置颜色，资源名称的分辨率为“真实”颜色在内部完成的 setComp1.setColors(new int[] { R.color.red1, R.color.red2, R.color.red3, R.color.red4 }, Context); LineDataSet setComp2 = new LineDataSet(valsComp2, &quot;Company 2&quot;); setComp2.setColors(new int[] { R.color.green1, R.color.green2, R.color.green3, R.color.green4 }, Context); 此外，还有许多其他方法可以设置颜色DataSet。以下是完整的文档： setColors(int [] colors, Context c)：设置在DataSet之前应该使用的颜色。数据集表示的条目数量高于颜色数组的大小时，颜色将重新使用。您可以使用“new int [] {R.color.red，R.color.green，…}”为此方法提供颜色。在内部，颜色使用getResources（）getColor（…）解析。 setColors(int [] colors)：设置在DataSet之前应该使用的颜色。数据集表示的条目数量高于颜色数组的大小时，颜色将重新使用。在将它们添加到DataSet之前，请确保颜色已经准备好了（通过调用getResources（）。getColor（…））。 setColors(ArrayList colors)：设置在DataSet之前应该使用的颜色。数据集表示的条目数量高于颜色数组的大小时，颜色将重新使用。在将它们添加到DataSet之前，请确保颜色已经准备好了（通过调用getResources（）。getColor（…））。 setColor(int color)：设置应该用于此DataSet的一个和唯一的颜色。在内部，这将重新创建颜色数组并添加指定的颜色。 ColorTemplate 例： LineDataSet set = new LineDataSet(...); set.setColors(ColorTemplate.VORDIPLOM_COLORS); 如果没有为一个DataSet设置颜色，则使用默认颜色。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.设置数据]]></title>
    <url>%2F2017%2F08%2F09%2F%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[本章介绍了将数据设置到各种类型的图表。 线型图如果要向图表添加值（数据），则必须通过 public void setData（ChartData data）{ ... } 方法。所述基类ChartData（ChartData）类封装了图表呈现期间所需的所有数据和信息。对于每种类型的图表，存在用于为图表设置数据的ChartData（例如LineData）的不同子类。在构造函数中，您可以将其List&lt;? extends IDataSet&gt;作为要显示的值进行切换。下面是一个LineData类（extends ChartData）的例子，用于将数据添加到LineChart： /**列表构造函数*/ public LineData（ List &lt; ILineDataSet &gt; sets）{ ... } /**构造与一个或多个ILineDataSet对象*/ 公共 LineData（ ILineDataSet 。..）{ ... } 那么，什么是一个DataSet，你为什么需要它？这其实很简单。一个DataSet对象表示图表中的Entry属于一起的一组条目（例如类）。它被设计为在图表中逻辑地分隔不同的值组。对于每种类型的图表，存在允许特定样式的扩展DataSet（例如LineDataSet）的不同对象。 例如，您可能希望显示在一年内两家不同公司的季度收入LineChart。在这种情况下，建议创建两个不同的LineDataSet对象，每个对象包含四个值（每个季度一个）。 当然，也可以LineDataSet为两个公司提供一个包含所有8个值的对象。 那么如何设置LineDataSet对象？ public LineDataSet（List &lt; Entry &gt; entries，String label）{ ... } 当查看构造函数（多种不同的构造函数可用）时，可以看到LineDataSet需要一个List类型Entry用于描述LineDataSet和一个String用作该标签的标签Legend。此外，此标签可用于查找对象中的LineDataSet 该List类型Entry封装了图表的所有值。一个Entry是围绕与x轴和y值在图表中的条目的的包装： public Entry（float x，float y）{ ... } 把它放在一起（两家公司季度收入超过一年的例子）： 首先，创建Entry类型列表来保存您的值： List&lt;Entry&gt; valsComp1 = new ArrayList&lt;Entry&gt;(); List&lt;Entry&gt; valsComp2 = new ArrayList&lt;Entry&gt;(); 然后，用Entry对象填写列表。确保条目对象包含x轴的正确索引。（当然，这里可以使用一个循环，在这种情况下，循环的计数器变量可以是x轴上的索引）。 Entry c1e1 = new Entry(0f, 100000f); // 0 == quarter 1 valsComp1.add(c1e1); Entry c1e2 = new Entry(1f, 140000f); // 1 == quarter 2 ... valsComp1.add(c1e2); // and so on ... Entry c2e1 = new Entry(0f, 130000f); // 0 == quarter 1 valsComp2.add(c2e1); Entry c2e2 = new Entry(1f, 115000f); // 1 == quarter 2 ... valsComp2.add(c2e2); //... 现在我们有了Entry对象列表，LineDataSet对象可以创建： LineDataSet setComp1 = new LineDataSet(valsComp1, &quot;Company 1&quot;); setComp1.setAxisDependency(AxisDependency.LEFT); LineDataSet setComp2 = new LineDataSet(valsComp2, &quot;Company 2&quot;); setComp2.setAxisDependency(AxisDependency.LEFT); 通过调用setAxisDependency(…)，DataSet应该绘制相对应的轴。但并非最后 最重要的是，我们创建一个IDataSets列表并构建我们的ChartData对象： //使用接口ILineDataSet List&lt;ILineDataSet&gt; dataSets = new ArrayList&lt;ILineDataSet&gt;(); dataSets.add(setComp1); dataSets.add(setComp2); LineData data = new LineData(dataSets); mLineChart.setData(data); mLineChart.invalidate(); //刷新 调用invalidate()后，图表刷新并展示所提供的数据。 如果我们要为x轴添加更多的描述性值（而不是不同季度的0到3的数字），我们可以通过使用IAxisValueFormatter接口来实现。这个界面允许XAxis自定义样式。在此示例中，格式化程序可能如下所示： //应该在XAxis上绘制的标签 final String[] quarters = new String[] { &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot; }; IAxisValueFormatter formatter = new IAxisValueFormatter() { @Override public String getFormattedValue(float value, AxisBase axis) { return quarters[(int) value]; } //我们不绘制数字，所以不需要十进制数字 @Override public int getDecimalDigits() { return 0; } }; XAxis xAxis = mLineChart.getXAxis(); xAxis.setGranularity(1f); // minimum axis-step（interval）为1 xAxis.setValueFormatter（格式化器）; 有关IAxisValueFormatter界面的详细信息，请参见此处。 如果应用了附加样式，则LineChart从此示例得到的样式应类似于以下内容： BarChart，ScatterChart，BubbleChart和CandleStickChart正常设定数据工作原理类似LineChart。一个特殊情况是BarChart有多个（分组）的条，这将在下面解释。 条目的顺序请注意，这个库并不正式支持从没有在上升方式中的条目的x位置排序的条目列表绘制折线图的数据。以未排序的方式添加条目可能会导致正确的绘制，但也可能导致意外的行为。一个Entry的List对象可以手动排序，也可以使用EntryXComparator： List&lt;Entry&gt; entries = ...; Collections.sort(entries, new EntryXComparator()); 必需是这样的原因是因为库使用二进制搜索算法来获得更好的性能，只能在排序列表上工作。 BarCharta BarChart设置数据的方式非常类似于LineChart。主要区别是需要用于设置数据的数据对象（例如，BarEntry而不是Entry）。除此之外，BarChart还有不同的风格选择。 请考虑以下填写BarChart数据的示例： List&lt;BarEntry&gt; entries = new ArrayList&lt;&gt;(); entries.add(new BarEntry(0f, 30f)); entries.add(new BarEntry(1f, 80f)); entries.add(new BarEntry(2f, 60f)); entries.add(new BarEntry(3f, 50f)); // gap of 2f entries.add(new BarEntry(5f, 70f)); entries.add(new BarEntry(6f, 60f)); BarDataSet set = new BarDataSet(entries, &quot;BarDataSet&quot;); 在上面的例子中，BarEntry创建了五个对象并将其添加到了BarDataSet。请注意，在第四个到第五个条目之间的x位置上存在“2”的差距。在这个例子中，这个差距用来解释杆在BarChart工程中的定位。本教程末尾的屏幕截图将显示BarChart给定数据的结果。作为下一步，BarData需要创建一个对象： BarData data = new BarData(set); data.setBarWidth(0.9f); //设置自定义栏宽度 chart.setData(data); chart.setFitBars(true); //使x轴完全适合所有酒吧 chart.invalidate(); //刷新 在上面的代码段中，BarData创建了一个对象。当BarEntry图表的对象创建时，我们在每个栏的（中心）之间的x轴上留下了一个“1f”空格。通过将条宽设置为0.9f，我们有效在每个条之间地创建一个0.1f的空间。setFitBars（true）调用会告诉图表调整它的x轴值的范围，以精确地适合所有的条，并且不会在两边切断条形。 创建BarData对象后，我们将其设置为图表并刷新。结果应该如下所示： 分组BarChart自版本V3.0.0以来，MPAndroidChart支持绘制条分组显式（在这种情况下，库将处理x位置）或用户定义，这意味着用户可以通过更改x位置来将栏放置在任何位置。 本节将重点介绍显式分组的BarChart，这意味着库将处理条的x位置。 请考虑以下示例设置： YourData[] group1 = ...; YourData[] group2 = ...; List&lt;BarEntry&gt; entriesGroup1 = new ArrayList&lt;&gt;(); List&lt;BarEntry&gt; entriesGroup2 = new ArrayList&lt;&gt;(); //填充列表 for(int i = 0; i &lt; group1.length; i++) { entriesGroup1.add(new BarEntry(i, group1.getValue())); entriesGroup2.add(new BarEntry(i, group2.getValue())); } BarDataSet set1 = new BarDataSet(entriesGroup1, &quot;Group 1&quot;); BarDataSet set2 = new BarDataSet(entriesGroup2, &quot;Group 2&quot;); 在这个例子中，我们将有两组条，每组由一个BarDataSet表示。 在显式（处理库）的情况下，条目的实际x位置并不重要。 根据条目列表中BarEntry的位置执行分组。 float groupSpace = 0.06f; float barSpace = 0.02f; // x2 dataset float barWidth = 0.45f; // x2 dataset // (0.02 + 0.45) * 2 + 0.06 = 1.00 -&gt; interval per &quot;group&quot; BarData data = new BarData(set1, set2); data.setBarWidth(barWidth); // set the width of each bar barChart.setData(data); barChart.groupBars(1980f, groupSpace, barSpace); // perform the &quot;explicit&quot; grouping barChart.invalidate(); // refresh 在上面的代码片段中，BarDataSet对象被添加到BarChart。 groupBars（…）方法执行两个BarDataSet对象的分组。 该方法采用以下参数： public void groupBars（float fromX，float groupSpace，float barSpace）{ ... } 该fromX参数确定XAxis分组栏应该在何处开始（在这种情况下为“1980”），groupSpace确定每组条之间留下的空间，barSpace确定组中单个条之间的空格。基于这些参数，该groupBars(…)方法改变每个条的XAxis朝向分组外观的位置，保持各个BarEntry对象的顺序。 每个组中的“间隔”（占用空间）XAxis也由参数groupSpace和barSpace参数定义barWidth。 结果应该是这样的： 当然，分组的BarChart也可以在不使用groupBars（…）方法的情况下实现，只需通过手动将各个条直接定位到XAxis上即可。 为了确保在XAxis上面的屏幕截图中的标签位于组之上，您可以使用以下setCenterAxisLabels(…)方法： XAxis xAxis = chart.getXAxis(); xAxis.setCenterAxisLabels(true); 堆叠BarChart堆叠的BarChart设置与普通的BarChart完全相似，除了BarEntry创建各个对象的方式之外。在堆叠条形的情况下，BarEntry必须使用不同的构造函数： public BarEntry（float x，float [] yValues）{ ... } 该构造函数允许提供多个yValues，它们表示每个栏的“堆栈”的值。考虑下面的示例对象： BarEntry stackedEntry = new BarEntry(0f, new float[] { 10, 20, 30 }); 这BarEntry包括三个值的堆叠，“高”为“10”，“20”和“30”。 PieChart与其他图表类型不同，PieChart以PieEntry对象的形式获取数据。 这些对象的构造函数如下所示： public PieEntry（float value，String label）{ ... } 构造函数的第一个参数用于在PieChart中应该绘制为饼图的实际“值”。 称为“label”的第二个String参数用于提供切片的其他描述。 请考虑以下示例PieChart设置： List&lt;PieEntry&gt; entries = new ArrayList&lt;&gt;(); entries.add(new PieEntry(18.5f, &quot;Green&quot;)); entries.add(new PieEntry(26.7f, &quot;Yellow&quot;)); entries.add(new PieEntry(24.0f, &quot;Red&quot;)); entries.add(new PieEntry(30.8f, &quot;Blue&quot;)); PieDataSet set = new PieDataSet(entries, &quot;Election Results&quot;); PieData data = new PieData(set); pieChart.setData(data); pieChart.invalidate(); // refresh PieEntry对象不能保存x位置的值，因为图表中显示的PieEntry对象的顺序由其在条目列表中的顺序确定。 添加一些额外的样式时，所得到的PieChart与上面使用的数据可能类似于：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Y轴（YAxis）]]></title>
    <url>%2F2017%2F08%2F09%2Fy%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[这YAxis是AxisBase的一个子类。这章只描述了YAxis，而不是它的超类AxisBase。 该YAxis类（比2.0.0更老版本的称呼为YLabels），是数据和一切与垂直轴相关的信息容器。每个Line-，Bar-，Scatter或CandleStickChart都有一个左YAxis对象和右YAxis对象，分别负责左轴或右轴。雷达图只有一个YAxis。默认情况下，图表的两个轴都被启用，并将被绘制。 为了获得一个实例中的YAxis类，请选择以下方法之一： YAxis leftAxis = chart.getAxisLeft(); YAxis rightAxis = chart.getAxisRight(); YAxis leftAxis = chart.getAxis(AxisDependency.LEFT); YAxis yAxis = radarChart.getYAxis(); //这个方法只有radarchart 在运行时，public AxisDependency getAxisDependency()用来确定该轴代表的图表的边。 在设置图表的数据之前，需要应用影响轴值范围的自定义。 轴依赖性默认情况下，添加到图表的所有数据都会在图表左侧YAxis绘制。如果没有进一步指定和启用，则右侧的值YAxis被调整为与左轴相同的刻度。 如果您的图表需要支持不同的轴刻度，则可以通过设置数据应该绘制的轴来实现。这可以通过改变AxisDependency来完成您的DataSet目标： LineDataSet dataSet = ... ; //获取一个数据集 dataSet.setAxisDependency(AxisDependency.RIGHT); 设置此项将更改您的数据绘制轴。 零线除了在每个值旁边起源的网格线之外，还有一个YAxis所谓的零滚动，它在轴上的零（0）值处绘制，并且与网格线类似，但可以单独配置。 setDrawZeroLine(boolean enabled)：启用/禁用绘制零线。 setZeroLineWidth(float width)：设置零行的行宽。 setZeroLineColor(int color)：设置零线应具有的颜色。 零线示例代码： //数据具有AxisDependency.LEFT YAxis left = mChart.getAxisLeft(); left.setDrawLabels(false); //无轴标签 left.setDrawAxisLine(false); //没有轴线 left.setDrawGridLines(false); //无网格线 left.setDrawZeroLine(true); //绘制零行 mChart.getAxisRight().setEnabled(false); //没有右轴 上述代码将导致zero-line如下图所示。不绘制轴值，不绘制网格线或轴线，仅只有zero-line。 更多示例代码YAxis yAxis = mChart.getAxisLeft(); yAxis.setTypeface（...）; //设置不同的字体 yAxis.setTextSize（12f）; //设置文字大小 yAxis.setAxisMinimum（0f）; //从零开始 yAxis.setAxisMaximum（100f）; //轴最大值为100 yAxis.setTextColor（颜色。 BLACK）; yAxis.setValueFormatter（new MyValueFormatter（））; yAxis.setGranularity（1f）; //间隔1 yAxis.setLabelCount（6，true）; //强制6个标签 // ...等等]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.X轴（XAxis）]]></title>
    <url>%2F2017%2F08%2F09%2Fx%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[XAxis是AxisBase的一个子类，它继承了许多样式和方便的方法。 XAxis类（在之前的2.0.0版本称为 XLabels），是用于一切有关水平轴的数据和信息的容器。每个Line-，Bar-，Scatter-，CandleStick-和RadarChart都有一个XAxis对象。 XAxis类允许特定的造型和由（可由）以下组分/部分组成： 所谓的“轴线”被直接绘制在标签上并与之平行 “网格线”，各自源于垂直方向的轴标签 为了获得一个实例中的XAxis类，请执行以下操作： XAxis xAxis = chart.getXAxis(); 自定义轴值 setLabelRotationAngle(float angle)：设置绘制x轴标签的角度（以度为单位）。 setPosition(XAxisPosition pos)：设置XAxis应显示的位置。在TOP，BOTTOM，BOTH_SIDED，TOP_INSIDE或BOTTOM_INSIDE之间进行选择。 示例代码 XAxis xAxis = chart.getXAxis(); xAxis.setPosition(XAxisPosition.BOTTOM); xAxis.setTextSize(10f); xAxis.setTextColor(Color.RED); xAxis.setDrawAxisLine(true); xAxis.setDrawGridLines(false); //设置一个自定义值格式化程序 xAxis.setValueFormatter(new MyCustomFormatter()); // and more…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.轴（AxisBase）]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%BD%B4%EF%BC%88AxisBase%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这个wiki页面的重点介绍AxisBase类，它是XAxis（X轴）和YAxis（Y轴）两者的基类，在v2.0.0中引入。 下面提到的以下方法可以应用于两个轴。 这个轴类允许特定的样式，包括（可以包括）以下组件/部件： 标签（以垂直（y轴）或水平（x轴）对齐绘制），其中包含轴描述值 所谓的“轴线”被直接绘制在标签上并与之平行 “网格线”，各自源自水平方向的轴标签 LimitLines允许提供特殊信息，如边界或约束 控制应绘制哪些零件（轴） setEnabled(boolean enabled)：设置轴启用或禁用。如果禁用，无论任何其他设置如何，都不会绘制轴的任何部分。 setDrawLabels(boolean enabled)：将其设置为true可以绘制轴的标签。 setDrawAxisLine(boolean enabled)：如果沿着轴（轴线）的线应该被绘制，则将其设置为true。 setDrawGridLines(boolean enabled)：将其设置为true可以绘制轴的网格线。 自定义轴范围（最小/最大） setAxisMaximum(float max)：设置此轴的自定义最大值。如果设置，此值将不会根据提供的数据自动计算。 resetAxisMaximum()：调用此命令来撤销先前设置的最大值。通过这样做，您将再次允许轴自动计算它的最大值。 setAxisMinimum(float min)：设置此轴的自定义最小值。如果设置，此值将不会根据提供的数据自动计算。 resetAxisMinimum()：调用此命令来撤消先前设置的最小值。通过这样做，您将再次允许轴自动计算它的最小值。 setStartAtZero(boolean enabled)：已弃用 - 使用setAxisMinValue(…)或setAxisMaxValue(…)替代。 setInverted(boolean enabled)：如果设置为true，则该轴将反转，这意味着最高值将在底部，最低值在顶部。 setSpaceTop(float percent)：与轴上的最高值相比，设置图表中最高值的顶部间距（以总轴范围的百分比表示）。 setSpaceBottom(float percent)：与轴上的最低值相比，设置图表中最低值的底部间距（以总轴范围的百分比表示）。 setShowOnlyMinMax(boolean enabled)：如果启用，该轴将仅显示其最小值和最大值。这将忽略/覆盖定义的标签计数（如果不强制）。 setLabelCount(int count, boolean force)：设置y轴的标签数量。请注意，这个数字是不固定的（如果强制== false），只能近似。如果强制启用（true），则绘制精确的指定标签计数 - 这可能导致轴上的数字不均匀。 setPosition(YAxisLabelPosition pos)：设置绘制轴标签的位置。INSIDE_CHART或OUTSIDE_CHART。 setGranularity(float gran)：设置y轴值之间的最小间隔。这可以用于在放大到为轴设置的小数位数不再允许区分两个轴值的点时避免重复值。 setGranularityEnabled(boolean enabled)：启用限制放大时y轴间隔的粒度特征。默认值：false 样式/修改轴 setTextColor(int color)：设置轴标签的颜色。 setTextSize(float size)：设置dp中轴标签的文本大小。 setTypeface(Typeface tf)：设置Typeface轴标签的自定义。 setGridColor(int color)：设置此轴的网格线的颜色。 setGridLineWidth(float width)：设置此轴的网格线的宽度。 setAxisLineColor(int color)：设置此轴的轴线的颜色。 setAxisLineWidth(float width)：设置此轴的轴线的宽度。 enableGridDashedLine(float lineLength, float spaceLength, float phase)：允许以虚线模式绘制网格线，例如像这样的“ - - - - - ”。“lineLength”控制线段的长度，“spaceLength”控制线间的空间，“phase”控制起点。 格式化轴值 对于格式化轴值，可以使用IAxisValueFormatter界面，它的介绍在这里。 您可以使用axis.setValueFormatter(IAxisValueFormatter formatter)方法将自定义格式化程序设置给轴。 限制线这两个轴支持所谓的LimitLines允许呈现特殊信息，如边界或约束。LimitLines添加到YAxis水平方向，并在垂直方向添加到XAxis。下边是您如何LimitLines从轴上添加和删​​除： addLimitLine(LimitLine l)：LimitLine向此轴添加新的。 removeLimitLine(LimitLine l)：LimitLine从该轴移除指定的。 更多添加/删除可用的方法。 setDrawLimitLinesBehindData(boolean enabled)：允许控制LimitLines和实际数据之间的z顺序。如果设置为true，则将LimitLines其拖放到实际数据之后，否则返回顶部。默认值：false 限制线（类LimitLine）（名称可能指示）可以使用简单线条为用户提供附加信息。 例如，您的图表可能会显示用户使用应用程序记录的各种血压测量结果。为了通知用户，超过140 mmHg的收缩压被认为是健康风险，您可以添加LimitLine140以提供该信息。 示例代码YAxis leftAxis = chart.getAxisLeft(); LimitLine ll = new LimitLine(140f, &quot;Critical Blood Pressure&quot;); ll.setLineColor(Color.RED); ll.setLineWidth(4f); ll.setTextColor(Color.BLACK); ll.setTextSize(12f); // .. and more styling options leftAxis.addLimitLine(ll);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.突出显示值]]></title>
    <url>%2F2017%2F08%2F08%2F%E7%AA%81%E5%87%BA%E6%98%BE%E7%A4%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[本节重点介绍基于版本v3.0.0，通过点击手势和编程方式突出显示图表中的条目的主题 启用/禁用突出显示 setHighlightPerDragEnabled(boolean enabled)：将其设置为true Chart，以便在完全缩小时在图表上拖动时突出显示。默认值：true setHighlightPerTapEnabled(boolean enabled)：将其设置为false，Chart以防止点击手势突出显示值。仍然可以通过拖动或以编程方式突出显示值。默认值：true setMaxHighlightDistance(float distanceDp)：设置dp中的最大高亮距离。图表上远离条目的图表距离不会触发高亮。默认值：500dp 除此之外，可以为单个DataSet对象配置突出显示： dataSet.setHighlightEnabled(true); //允许突出显示DataSet //将此设置为false可禁用高亮指示符（lines） dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator // and more ... 以编程方式突出显示 highlightValue(float x, int dataSetIndex, boolean callListener)：突出显示给定DataSet中给定x位置的值。提供-1作为dataSetIndex以撤消所有突出显示。布尔标志决定了应该调用选择侦听器。 highlightValue(Highlight high, boolean callListener)：突出显示提供的Highlight对象所代表的值。提供null以撤销所有突出显示。布尔标志决定了应该调用选择侦听器。 highlightValues(Highlight[] highs)：突出显示给定Highlight[]数组所表示的值。提供null或一个空数组来撤消所有突出显示。 getHighlighted()：返回一个Highlight[]数组，其中包含有关所有突出显示的条目及其x-index和dataset-index的信息。 选择回调该库在交互时提供了许多用于回调的侦听器。其中一个是OnChartValueSelectedListener通过触摸突出显示值时的回调： public interface OnChartValueSelectedListener { / ** *当在图表中选择了一个值时调用。 * * @param e所选条目。 * @param h相应的突出显示对象，其中包含关于突出显示位置的信息 * / public void onValueSelected（Entry e，Highlight h）; / ** *当没有选择任何东西或进行“未选择”时调用。 * / public void onNothingSelected（）; } 只需让你的应该接收回调的类实现这个接口并将其设置为监听器到图表： chart.setOnChartValueSelectedListener(this); 亮点类所述Highlight类表示与突出相关联的所有数据Entry，如突出显示的Entry对象本身，DataSet它属于，它的绘图表面更上的位置。它可以用于获取有关已经突出显示的信息Entry，或用于提供信息以Chart供Entry高亮显示。为此目的，Highlight该类提供了两个构造函数： /**标准亮点的构造函数* / public Highlight（ float x， int dataSetIndex）{ ... } /**堆叠BarEntry高亮度的构造函数* / public Highlight（ float x， int dataSetIndex， int stackIndex）{ ... } 这些构造函数可用于创建Highlight允许以编程方式执行突出显示的对象： //突出显示第一个（0）数据集中的条目和x位置50 Highlight highlight = new Highlight(50f, 0); chart.highlightValue(highlight, false); //突出显示此值，不要调用监听器 自定义荧光笔所有以高亮手势形式显示的用户输入都由默认ChartHighlighter类进行内部处理。使用以下方法可以使用自定义实现替换默认的highligher： setHighlighter(ChartHighlighter highlighter)：为处理/处理在图表视图中执行的所有突出显示触摸事件的图表设置自定义高亮对象。您的自定义荧光笔对象需要扩展ChartHighlighter类。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.与图表的互动]]></title>
    <url>%2F2017%2F08%2F08%2F%E4%B8%8E%E5%9B%BE%E8%A1%A8%E7%9A%84%E4%BA%92%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[该库允许您完全自定义与图表视图的触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用互动 setTouchEnabled(boolean enabled)：允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled)：启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled)：启用/禁用两个轴上图表的缩放。 setScaleXEnabled(boolean enabled)：启用/禁用x轴上的缩放。 setScaleYEnabled(boolean enabled)：启用/禁用y轴上的缩放。 setPinchZoom(boolean enabled)：如果设置为true，则可以使用缩小缩放。如果禁用，可以单独放大x轴和y轴。 setDoubleTapToZoomEnabled(boolean enabled)：将其设置为false可禁止通过双击来缩放图表。 图表闪烁/减速 setDragDecelerationEnabled(boolean enabled)：如果设置为true，图表在触摸后继续滚动。默认值：true。 setDragDecelerationFrictionCoef(float coef)：减速摩擦系数在[0; 1]间隔，较高的值表示速度将缓慢降低，例如，如果设置为0，它将立即停止。1是无效值，将自动转换为0.9999。 突出显示值突出显示部分将介绍如何通过点按手势和编程方式突出显示条目。 手势回调OnChartGestureListener将允许您对图表上的手势做出反应： public interface OnChartGestureListener { /** *当触摸手势在图表上开始时的回调（ACTION_DOWN） * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * 当触摸手势在图表上结束时的回调(ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * 当图表被长按时回调。 * * @param me */ public void onChartLongPressed(MotionEvent me); /** *图表双击时回调。 * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** *当图表单点击时回调。 * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * 在图表上做出一个简单的滑动时回调。 * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** *当图表通过缩放手势缩放/缩放时回调。 * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** *当图表通过拖动手势移动/翻转时回调。 * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY); } 只需让你的应该接收回调的类实现这个接口并将其设置为监听器到图表： chart.setOnChartGestureListener(this);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.入门]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本章介绍使用此库的基本设置。 添加依赖项作为第一步，将这个库的依赖项添加到您的项目中。在这个存储库的使用部分描述了如何做到这一点。Gradle是使用此库作为依赖关系的推荐方法。 创建视图 对于使用a LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在.xml中定义它： &lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后从你的Activity，Fragment或其它布局检索： // 在这个例子当中 LineChart 是在 xml重初始化的 LineChart chart = (LineChart) findViewById(R.id.chart); 或者在代码中创建它（然后将其添加到布局）： //以编程方式创建一个LineChart LineChart chart = new LineChart(Context); //取得在XML定义的布局 RelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout); rl.add(chart); //添加以编程方式创建的图表 添加数据拥有图表实例后，您可以创建数据并将其添加到图表中。此示例使用LineChart类，其中Entry表示图表中具有x和y坐标的单个条目。其他图表类型，例如BarChart使用其他类（例如BarEntry）。 要将数据添加到图表中，应将每个数据对象包含到Entry对象中，如下所示： YourData[] dataObjects = ...; List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;(); for (YourData data : dataObjects) { //将您的数据转换为Entry对象 entries.add(new Entry(data.getValueX(), data.getValueY())); } 作为下一步，您需要将你创建的List对象添加到一个LineDataSet对象。DataSet对象持有属于一类的数据，并允许对该数据进行单独样式。如果启用，下面使用的“标签”只有一个描述性的目的，并显示在Legend中。 LineDataSet dataSet = new LineDataSet（entries，“ Label ”）; //添加条目到数据集 dataSet.setColor（...）; dataSet.setValueTextColor（...）; //造型，... 作为最后一步，您需要将创建的LineDataSet对象添加到LineData对象。该对象包含由Chart实例表示的所有数据，并允许进一步的设置样式。创建数据对象后，可以将其设置给图表并刷新： LineData lineData = new LineData(dataSet); chart.setData(lineData); chart.invalidate(); // refresh 上述情况只是一个非常基本的设置。有关更详细的说明，请参阅设置数据部分，其中介绍了根据示例如何将数据添加到各种类型Chart。 造型有关图表和数据的设置和样式的信息，请访问常规设置和样式部分。关于个别图表类型的更具体的样式和设置，请查看具体设置和样式 wiki页面。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPAndroidChart库的viki翻译]]></title>
    <url>%2F2017%2F08%2F06%2FMPAndroidChart%E6%96%87%E6%A1%A3%E7%9A%84viki%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[欢迎使用MPAndroidChart库的文档。 文档章节 入门 与图表的相互作用 突出显示值 轴（AxisBase） XAxis YAxis 设置数据 设置颜色 格式化数据值（ValueFormatter） 格式化轴值（AxisValueFormatter） 一般设置和样式 具体设置和样式 传说 动态和实时数据 修改视口 动画 MarkerView（Popup View） ChartData类 ChartData子类 DataSet类（一般的DataSet样式） DataSet子类（特定DataSet样式） ViewPortHandler 定制填充线位置（FillFormatter） 保镖 Realm.io手机数据库 创建自己的（自定义）DataSet 其他（更有用的东西） 其他信息 使用此库的项目（参考） 性能]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Accessibility(辅助功能)学习]]></title>
    <url>%2F2017%2F05%2F10%2FAndroid-Accessibility-%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[写在前面前一段项目的需要（需要自动开启微信并自动添加通讯录好友以及发朋友圈）接触了关于AccessibilityService(辅助功能)的开发。刚开始的时候根本没有想到可以用辅助功能来帮助实现这个需求，一直在研究屏幕监听和模拟点击功能，因为手机没有root屏幕监听和模拟点击功能不可以用，后来通过和同事讨论，发现可以使用辅助功能来实现这一需求。Accessibility主要目的是帮助一些因为有视觉，听觉，身体障碍而无法完全使用触摸屏或铃声等的用户来使用Android的。而实际上现在很多开发者都用它来实现一些其他功能了，比如说微信抢红包，自动安装APK，强制停止应用等。那么接下来开始介绍这个AccessibilityService（辅助功能）: AccessibilityService的使用 AccessibilityService是Service的子类，运行在后台,并且能够收到由系统发出的一些事件(AccessibilityEvent,这些事件表示用户界面一系列的状态变化),比如焦点改变,输入内容变化,按钮被点击了等等,该种服务能够请求获取当前活动窗口并查找其中的内容.换言之,界面中产生的任何变化都会产生一个时间,并由系统通知给AccessibilityService.这就像监视器监视着界面的一举一动,一旦界面发生变化,立刻发出警报. 创建自己的服务类创建自己的服务类,需要继承AccessibilityService类。 需要重载以下方法： onServiceConnected() 系统会在成功连接上你的服务的时候调用这个方法，在这个方法里你可以做一下初始化工作，例如设备的声音震动管理，也可以调用setServiceInfo()进行配置工作。 onAccessibilityEvent() 通过这个函数可以接收系统发送来的AccessibilityEvent，接收来的AccessibilityEvent是经过过滤的，过滤是在配置工作时设置的。 onInterrupt() 这个在系统想要中断AccessibilityService返给的响应时会调用。在整个生命周期里会被调用多次。 onUnbind(Intent intent) 在系统将要关闭这个AccessibilityService会被调用。在这个方法中进行一些释放资源的工作 声明和其它Service服务一样，需要在AndroidManifest.xml声明，而且还要做以下两件事： 指定intent-filter为 “android.accessibilityservice.AccessibilityService” 添加 BIND_ACCESSIBILITY_SERVICE权限，确保只有系统可以绑定到它** 如果项目中缺少任意一个，系统会忽略AccessibilityService。下面是一个声明例子： &lt;service android:name=&quot;.MyAccessibilityService&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; . . . &lt;/service&gt; 参数配置AccessibilityService可以配置用来接收特定类型的事件，只监听特定的packages，在特定的时间内只能获得每种事件只有一次，检索窗口内容,指定一个设置活动,等等 配置AccessibilityService有两种方法: 在声明服务时，在AndroidManifest.xml中提供一个meta-data。下面给出了一个带有meta-data的服务声明: &lt;service android:name=&quot;.MyAccessibilityService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessibilityservice&quot; /&gt; &lt;/service&gt; accessibility.xml的相关配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeAllMask&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:accessibilityFlags=&quot;flagDefault&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/accessibility_service_description&quot; android:notificationTimeout=&quot;100&quot; android:packageNames=&quot;com.tencent.mm,com.yulong.android.launcherL&quot; /&gt; 注意：此方法使设置的所有属性。欲了解更多详情，请参阅 SERVICE_META_DATA和accessibility-service。 调用setServiceInfo(AccessibilityServiceInfo)。注意，此方法可以任何时候调用来动态地更改AccessibilityService的配置。 @Override protected void onServiceConnected() { AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo(); serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK; serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC; serviceInfo.packageNames = new String[]{&quot;com.tencent.mm,com.yulong.android.launcherL&quot;}; serviceInfo.notificationTimeout=100; setServiceInfo(serviceInfo); } 注意：这种方法只可以设置动态配置属性：eventTypes，feedbackType，flags，notificationTimeout，packageNames; 欲了解更多详情，请参阅AccessibilityServiceInfo。 现在我们对配置中的重要属性进行说明: accessibilityEventTypes: 表示接收事件的类型： 方法 说明 AccessibilityEvent.TYPES_ALL_MASK 全局事件响应 AccessibilityEvent.TYPE_VIEW_CLICKED 点击事件 accessibilityFeedbackType:表示反馈方式: 方法 说明 AccessibilityServiceInfo.FEEDBACK_GENERIC 通用的反馈 AccessibilityServiceInfo.FEEDBACK_AUDIBLE 声音反馈 canRetrieveWindowContent: 表示该服务能否访问活动窗口中的内容.如果在服务中获取窗体内容的化,则需要设置其值为true. notificationTimeout: 接受事件的时间间隔,通常将其设置为100. packageNames: 表示对该服务是用来监听哪个包的产生的事件,中间可以用&quot;,&quot;分隔开。 监听指定类型事件监听AccessibilityEvent事件我们在onAccessibilityEvent(AccessibilityEvent event)方法中进行： @Override public void onAccessibilityEvent(AccessibilityEvent event) { int eventType = event.getEventType(); switch (eventType) { case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED: //通知栏消息 break; case AccessibilityEvent.TYPE_VIEW_CLICKED: //界面点击 break; //....... } } 这个事件类型很多的，我们可以查看AccessibilityEvent类的源码： @Deprecated public static final int MAX_TEXT_LENGTH = 500; /** * Represents the event of clicking on a {@link android.view.View} like * {@link android.widget.Button}, {@link android.widget.CompoundButton}, etc. */ public static final int TYPE_VIEW_CLICKED = 0x00000001; /** * Represents the event of long clicking on a {@link android.view.View} like * {@link android.widget.Button}, {@link android.widget.CompoundButton}, etc. */ public static final int TYPE_VIEW_LONG_CLICKED = 0x00000002; /** * Represents the event of selecting an item usually in the context of an * {@link android.widget.AdapterView}. */ public static final int TYPE_VIEW_SELECTED = 0x00000004; /** * Represents the event of setting input focus of a {@link android.view.View}. */ public static final int TYPE_VIEW_FOCUSED = 0x00000008; /** * Represents the event of changing the text of an {@link android.widget.EditText}. */ public static final int TYPE_VIEW_TEXT_CHANGED = 0x00000010; /** * Represents the event of opening a {@link android.widget.PopupWindow}, * {@link android.view.Menu}, {@link android.app.Dialog}, etc. */ public static final int TYPE_WINDOW_STATE_CHANGED = 0x00000020; /** * Represents the event showing a {@link android.app.Notification}. */ public static final int TYPE_NOTIFICATION_STATE_CHANGED = 0x00000040; /** * Represents the event of a hover enter over a {@link android.view.View}. */ public static final int TYPE_VIEW_HOVER_ENTER = 0x00000080; /** * Represents the event of a hover exit over a {@link android.view.View}. */ public static final int TYPE_VIEW_HOVER_EXIT = 0x00000100; /** * Represents the event of starting a touch exploration gesture. */ public static final int TYPE_TOUCH_EXPLORATION_GESTURE_START = 0x00000200; /** * Represents the event of ending a touch exploration gesture. */ public static final int TYPE_TOUCH_EXPLORATION_GESTURE_END = 0x00000400; /** * Represents the event of changing the content of a window and more * specifically the sub-tree rooted at the event&apos;s source. */ public static final int TYPE_WINDOW_CONTENT_CHANGED = 0x00000800; /** * Represents the event of scrolling a view. */ public static final int TYPE_VIEW_SCROLLED = 0x00001000; /** * Represents the event of changing the selection in an {@link android.widget.EditText}. */ public static final int TYPE_VIEW_TEXT_SELECTION_CHANGED = 0x00002000; /** * Represents the event of an application making an announcement. */ public static final int TYPE_ANNOUNCEMENT = 0x00004000; /** * Represents the event of gaining accessibility focus. */ public static final int TYPE_VIEW_ACCESSIBILITY_FOCUSED = 0x00008000; /** * Represents the event of clearing accessibility focus. */ public static final int TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED = 0x00010000; /** * Represents the event of traversing the text of a view at a given movement granularity. */ public static final int TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY = 0x00020000; /** * Represents the event of beginning gesture detection. */ public static final int TYPE_GESTURE_DETECTION_START = 0x00040000; /** * Represents the event of ending gesture detection. */ public static final int TYPE_GESTURE_DETECTION_END = 0x00080000; /** * Represents the event of the user starting to touch the screen. */ public static final int TYPE_TOUCH_INTERACTION_START = 0x00100000; /** * Represents the event of the user ending to touch the screen. */ public static final int TYPE_TOUCH_INTERACTION_END = 0x00200000; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The type of change is not defined. */ public static final int CONTENT_CHANGE_TYPE_UNDEFINED = 0x00000000; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * A node in the subtree rooted at the source node was added or removed. */ public static final int CONTENT_CHANGE_TYPE_SUBTREE = 0x00000001; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The node&apos;s text changed. */ public static final int CONTENT_CHANGE_TYPE_TEXT = 0x00000002; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The node&apos;s content description changed. */ public static final int CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION = 0x00000004; 查找节点View系统提供了两个方法让我们来进行查找想要的节点View： 通过节点View的Text内容来查找：findAccessibilityNodeInfosByText(“查找内容”)这种方式查找，就是像TextView,Button等View有文本内容的，可以使用这种方式快速的找到。 nodes = getRootInActiveWindow().findAccessibilityNodeInfosByText(&quot;手机联系人&quot;); if (nodes != null &amp;&amp; nodes.size() &gt; 0) { AccessibilityNodeInfo node = nodes.get(0).getParent(); node.performAction(AccessibilityNodeInfo.ACTION_CLICK); } 第二种是通过节点View在xml布局中的id名称来查找：findAccessibilityNodeInfosByViewId(“@id/xxx”)；(关于怎样找到View在xml布局中的id我下面有说明) nodes = getRootInActiveWindow().findAccessibilityNodeInfosByViewId(&quot;com.tencent.mm:id/f_&quot;); if (nodes != null &amp;&amp; nodes.size() &gt; 0) { for (int i = 0; i &lt; nodes.size(); i++) { node = nodes.get(i).getParent(); node.performAction(AccessibilityNodeInfo.ACTION_CLICK); } } 模拟点击指定事件我们找到我们想要的View节点，调用方法模拟事件： 调用performAction(AccessibilityNodeInfo.ACTION_CLICK)这个方法即可 当然这里的参数就是指定事件的名称，这个和AccessibilityEvent中监听的那些事件是一一对应的，这里是模拟点击事件，我们当然可以模拟View的滚动事件，长按事件等。 实际应用——微信抢红包插件上面我们就介绍了一个辅助功能开发的具体步骤，那么下面就通过一个简单的例子，来实战一下：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Accessibility</tag>
        <tag>辅助功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[底部导航栏凸起效果]]></title>
    <url>%2F2017%2F03%2F15%2FAndroid%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%87%B8%E8%B5%B7%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[先上效果图 此底部导航栏的布局很简单，其中用到的最主要的就是在突出布局的父布局设置android:clipChildren为false即可，默认为true，android:clipChildren的意思：是否限制子View在其范围内，然后设置突出布局android:layout_gravity=”bottom”就可以了 最后贴出代码，使用RadioGroup+RadioButton实现的底部导航 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clipChildren=&quot;false&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewPager android:id=&quot;@+id/vp_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/ViewPager&gt; &lt;View android:id=&quot;@+id/div_view&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1.0px&quot; android:background=&quot;#d9d9d9&quot; /&gt; &lt;RadioGroup android:id=&quot;@+id/rg_group&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;@color/apTabBackground&quot; android:clipChildren=&quot;false&quot; android:elevation=&quot;8dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:id=&quot;@+id/first&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:checked=&quot;true&quot; android:drawableTop=&quot;@drawable/first_selector&quot; android:text=&quot;首页&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/second&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/second_selector&quot; android:text=&quot;学堂&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/third&quot; style=&quot;@style/Bottom_Tab_Style1&quot; android:layout_gravity=&quot;bottom&quot; android:clipChildren=&quot;false&quot; android:drawableBottom=&quot;@drawable/third_selector&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/fourth&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/fourth_selector&quot; android:text=&quot;互动&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/fifth&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/fifth_selector&quot; android:text=&quot;我&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，技术博客]]></title>
    <url>%2F2017%2F03%2F08%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。第一次写博客，请多多关照]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>