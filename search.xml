<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2.与图表的互动]]></title>
    <url>%2F2017%2F08%2F08%2F%E4%B8%8E%E5%9B%BE%E8%A1%A8%E7%9A%84%E4%BA%92%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[该库允许您完全自定义与图表视图的触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用互动 setTouchEnabled(boolean enabled)：允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled)：启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled)：启用/禁用两个轴上图表的缩放。 setScaleXEnabled(boolean enabled)：启用/禁用x轴上的缩放。 setScaleYEnabled(boolean enabled)：启用/禁用y轴上的缩放。 setPinchZoom(boolean enabled)：如果设置为true，则可以使用缩小缩放。如果禁用，可以单独放大x轴和y轴。 setDoubleTapToZoomEnabled(boolean enabled)：将其设置为false可禁止通过双击来缩放图表。 图表闪烁/减速 setDragDecelerationEnabled(boolean enabled)：如果设置为true，图表在触摸后继续滚动。默认值：true。 setDragDecelerationFrictionCoef(float coef)：减速摩擦系数在[0; 1]间隔，较高的值表示速度将缓慢降低，例如，如果设置为0，它将立即停止。1是无效值，将自动转换为0.9999。突出显示值 突出显示部分将介绍如何通过点按手势和编程方式突出显示条目。 手势回调OnChartGestureListener将允许您对图表上的手势做出反应： public interface OnChartGestureListener { /** *当触摸手势在图表上开始时的回调（ACTION_DOWN） * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * 当触摸手势在图表上结束时的回调(ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * 当图表被长按时回调。 * * @param me */ public void onChartLongPressed(MotionEvent me); /** *图表双击时回调。 * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** *当图表单点击时回调。 * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * 在图表上做出一个简单的滑动时回调。 * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** *当图表通过缩放手势缩放/缩放时回调。 * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** *当图表通过拖动手势移动/翻转时回调。 * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY); } 只需让你的应该接收回调的类实现这个接口并将其设置为监听器到图表： chart.setOnChartGestureListener(this);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.入门]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本章介绍使用此库的基本设置。 添加依赖项作为第一步，将这个库的依赖项添加到您的项目中。在这个存储库的使用部分描述了如何做到这一点。Gradle是使用此库作为依赖关系的推荐方法。 创建视图 对于使用a LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在.xml中定义它： &lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后从你的Activity，Fragment或其它布局检索： // 在这个例子当中 LineChart 是在 xml重初始化的 LineChart chart = (LineChart) findViewById(R.id.chart); 或者在代码中创建它（然后将其添加到布局）： //以编程方式创建一个LineChart LineChart chart = new LineChart(Context); //取得在XML定义的布局 RelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout); rl.add(chart); //添加以编程方式创建的图表 添加数据拥有图表实例后，您可以创建数据并将其添加到图表中。此示例使用LineChart类，其中Entry表示图表中具有x和y坐标的单个条目。其他图表类型，例如BarChart使用其他类（例如BarEntry）。 要将数据添加到图表中，应将每个数据对象包含到Entry对象中，如下所示： YourData[] dataObjects = ...; List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;(); for (YourData data : dataObjects) { //将您的数据转换为Entry对象 entries.add(new Entry(data.getValueX(), data.getValueY())); } 作为下一步，您需要将你创建的List对象添加到一个LineDataSet对象。DataSet对象持有属于一类的数据，并允许对该数据进行单独样式。如果启用，下面使用的“标签”只有一个描述性的目的，并显示在Legend中。 LineDataSet dataSet = new LineDataSet（entries，“ Label ”）; //添加条目到数据集 dataSet.setColor（...）; dataSet.setValueTextColor（...）; //造型，... 作为最后一步，您需要将创建的LineDataSet对象添加到LineData对象。该对象包含由Chart实例表示的所有数据，并允许进一步的设置样式。创建数据对象后，可以将其设置给图表并刷新： LineData lineData = new LineData(dataSet); chart.setData(lineData); chart.invalidate(); // refresh 上述情况只是一个非常基本的设置。有关更详细的说明，请参阅设置数据部分，其中介绍了根据示例如何将数据添加到各种类型Chart。 造型有关图表和数据的设置和样式的信息，请访问常规设置和样式部分。关于个别图表类型的更具体的样式和设置，请查看具体设置和样式 wiki页面。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
        <tag>K线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPAndroidChart库的viki翻译]]></title>
    <url>%2F2017%2F08%2F06%2FMPAndroidChart%E6%96%87%E6%A1%A3%E7%9A%84viki%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[欢迎使用MPAndroidChart库的文档。 文档章节 入门 与图表的相互作用 突出显示值 轴（AxisBase） XAxis YAxis 设置数据 设置颜色 格式化数据值（ValueFormatter） 格式化轴值（AxisValueFormatter） 一般设置和样式 具体设置和样式 传说 动态和实时数据 修改视口 动画 MarkerView（Popup View） ChartData类 ChartData子类 DataSet类（一般的DataSet样式） DataSet子类（特定DataSet样式） ViewPortHandler 定制填充线位置（FillFormatter） 保镖 Realm.io手机数据库 创建自己的（自定义）DataSet 其他（更有用的东西） 其他信息 使用此库的项目（参考） 性能]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MPAndroidChart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Accessibility(辅助功能)学习]]></title>
    <url>%2F2017%2F05%2F10%2FAndroid-Accessibility-%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[写在前面前一段项目的需要（需要自动开启微信并自动添加通讯录好友以及发朋友圈）接触了关于AccessibilityService(辅助功能)的开发。刚开始的时候根本没有想到可以用辅助功能来帮助实现这个需求，一直在研究屏幕监听和模拟点击功能，因为手机没有root屏幕监听和模拟点击功能不可以用，后来通过和同事讨论，发现可以使用辅助功能来实现这一需求。Accessibility主要目的是帮助一些因为有视觉，听觉，身体障碍而无法完全使用触摸屏或铃声等的用户来使用Android的。而实际上现在很多开发者都用它来实现一些其他功能了，比如说微信抢红包，自动安装APK，强制停止应用等。那么接下来开始介绍这个AccessibilityService（辅助功能）: AccessibilityService的使用 AccessibilityService是Service的子类，运行在后台,并且能够收到由系统发出的一些事件(AccessibilityEvent,这些事件表示用户界面一系列的状态变化),比如焦点改变,输入内容变化,按钮被点击了等等,该种服务能够请求获取当前活动窗口并查找其中的内容.换言之,界面中产生的任何变化都会产生一个时间,并由系统通知给AccessibilityService.这就像监视器监视着界面的一举一动,一旦界面发生变化,立刻发出警报. 创建自己的服务类创建自己的服务类,需要继承AccessibilityService类。 需要重载以下方法： onServiceConnected() 系统会在成功连接上你的服务的时候调用这个方法，在这个方法里你可以做一下初始化工作，例如设备的声音震动管理，也可以调用setServiceInfo()进行配置工作。 onAccessibilityEvent() 通过这个函数可以接收系统发送来的AccessibilityEvent，接收来的AccessibilityEvent是经过过滤的，过滤是在配置工作时设置的。 onInterrupt() 这个在系统想要中断AccessibilityService返给的响应时会调用。在整个生命周期里会被调用多次。 onUnbind(Intent intent) 在系统将要关闭这个AccessibilityService会被调用。在这个方法中进行一些释放资源的工作 声明和其它Service服务一样，需要在AndroidManifest.xml声明，而且还要做以下两件事： 指定intent-filter为 “android.accessibilityservice.AccessibilityService” 添加 BIND_ACCESSIBILITY_SERVICE权限，确保只有系统可以绑定到它** 如果项目中缺少任意一个，系统会忽略AccessibilityService。下面是一个声明例子： &lt;service android:name=&quot;.MyAccessibilityService&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; . . . &lt;/service&gt; 参数配置AccessibilityService可以配置用来接收特定类型的事件，只监听特定的packages，在特定的时间内只能获得每种事件只有一次，检索窗口内容,指定一个设置活动,等等 配置AccessibilityService有两种方法: 在声明服务时，在AndroidManifest.xml中提供一个meta-data。下面给出了一个带有meta-data的服务声明: &lt;service android:name=&quot;.MyAccessibilityService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessibilityservice&quot; /&gt; &lt;/service&gt; accessibility.xml的相关配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeAllMask&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:accessibilityFlags=&quot;flagDefault&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/accessibility_service_description&quot; android:notificationTimeout=&quot;100&quot; android:packageNames=&quot;com.tencent.mm,com.yulong.android.launcherL&quot; /&gt; 注意：此方法使设置的所有属性。欲了解更多详情，请参阅 SERVICE_META_DATA和accessibility-service。 调用setServiceInfo(AccessibilityServiceInfo)。注意，此方法可以任何时候调用来动态地更改AccessibilityService的配置。 @Override protected void onServiceConnected() { AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo(); serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK; serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC; serviceInfo.packageNames = new String[]{&quot;com.tencent.mm,com.yulong.android.launcherL&quot;}; serviceInfo.notificationTimeout=100; setServiceInfo(serviceInfo); } 注意：这种方法只可以设置动态配置属性：eventTypes，feedbackType，flags，notificationTimeout，packageNames; 欲了解更多详情，请参阅AccessibilityServiceInfo。 现在我们对配置中的重要属性进行说明: accessibilityEventTypes: 表示接收事件的类型： 方法 说明 AccessibilityEvent.TYPES_ALL_MASK 全局事件响应 AccessibilityEvent.TYPE_VIEW_CLICKED 点击事件 accessibilityFeedbackType:表示反馈方式: 方法 说明 AccessibilityServiceInfo.FEEDBACK_GENERIC 通用的反馈 AccessibilityServiceInfo.FEEDBACK_AUDIBLE 声音反馈 canRetrieveWindowContent: 表示该服务能否访问活动窗口中的内容.如果在服务中获取窗体内容的化,则需要设置其值为true. notificationTimeout: 接受事件的时间间隔,通常将其设置为100. packageNames: 表示对该服务是用来监听哪个包的产生的事件,中间可以用&quot;,&quot;分隔开。 监听指定类型事件监听AccessibilityEvent事件我们在onAccessibilityEvent(AccessibilityEvent event)方法中进行： @Override public void onAccessibilityEvent(AccessibilityEvent event) { int eventType = event.getEventType(); switch (eventType) { case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED: //通知栏消息 break; case AccessibilityEvent.TYPE_VIEW_CLICKED: //界面点击 break; //....... } } 这个事件类型很多的，我们可以查看AccessibilityEvent类的源码： @Deprecated public static final int MAX_TEXT_LENGTH = 500; /** * Represents the event of clicking on a {@link android.view.View} like * {@link android.widget.Button}, {@link android.widget.CompoundButton}, etc. */ public static final int TYPE_VIEW_CLICKED = 0x00000001; /** * Represents the event of long clicking on a {@link android.view.View} like * {@link android.widget.Button}, {@link android.widget.CompoundButton}, etc. */ public static final int TYPE_VIEW_LONG_CLICKED = 0x00000002; /** * Represents the event of selecting an item usually in the context of an * {@link android.widget.AdapterView}. */ public static final int TYPE_VIEW_SELECTED = 0x00000004; /** * Represents the event of setting input focus of a {@link android.view.View}. */ public static final int TYPE_VIEW_FOCUSED = 0x00000008; /** * Represents the event of changing the text of an {@link android.widget.EditText}. */ public static final int TYPE_VIEW_TEXT_CHANGED = 0x00000010; /** * Represents the event of opening a {@link android.widget.PopupWindow}, * {@link android.view.Menu}, {@link android.app.Dialog}, etc. */ public static final int TYPE_WINDOW_STATE_CHANGED = 0x00000020; /** * Represents the event showing a {@link android.app.Notification}. */ public static final int TYPE_NOTIFICATION_STATE_CHANGED = 0x00000040; /** * Represents the event of a hover enter over a {@link android.view.View}. */ public static final int TYPE_VIEW_HOVER_ENTER = 0x00000080; /** * Represents the event of a hover exit over a {@link android.view.View}. */ public static final int TYPE_VIEW_HOVER_EXIT = 0x00000100; /** * Represents the event of starting a touch exploration gesture. */ public static final int TYPE_TOUCH_EXPLORATION_GESTURE_START = 0x00000200; /** * Represents the event of ending a touch exploration gesture. */ public static final int TYPE_TOUCH_EXPLORATION_GESTURE_END = 0x00000400; /** * Represents the event of changing the content of a window and more * specifically the sub-tree rooted at the event&apos;s source. */ public static final int TYPE_WINDOW_CONTENT_CHANGED = 0x00000800; /** * Represents the event of scrolling a view. */ public static final int TYPE_VIEW_SCROLLED = 0x00001000; /** * Represents the event of changing the selection in an {@link android.widget.EditText}. */ public static final int TYPE_VIEW_TEXT_SELECTION_CHANGED = 0x00002000; /** * Represents the event of an application making an announcement. */ public static final int TYPE_ANNOUNCEMENT = 0x00004000; /** * Represents the event of gaining accessibility focus. */ public static final int TYPE_VIEW_ACCESSIBILITY_FOCUSED = 0x00008000; /** * Represents the event of clearing accessibility focus. */ public static final int TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED = 0x00010000; /** * Represents the event of traversing the text of a view at a given movement granularity. */ public static final int TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY = 0x00020000; /** * Represents the event of beginning gesture detection. */ public static final int TYPE_GESTURE_DETECTION_START = 0x00040000; /** * Represents the event of ending gesture detection. */ public static final int TYPE_GESTURE_DETECTION_END = 0x00080000; /** * Represents the event of the user starting to touch the screen. */ public static final int TYPE_TOUCH_INTERACTION_START = 0x00100000; /** * Represents the event of the user ending to touch the screen. */ public static final int TYPE_TOUCH_INTERACTION_END = 0x00200000; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The type of change is not defined. */ public static final int CONTENT_CHANGE_TYPE_UNDEFINED = 0x00000000; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * A node in the subtree rooted at the source node was added or removed. */ public static final int CONTENT_CHANGE_TYPE_SUBTREE = 0x00000001; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The node&apos;s text changed. */ public static final int CONTENT_CHANGE_TYPE_TEXT = 0x00000002; /** * Change type for {@link #TYPE_WINDOW_CONTENT_CHANGED} event: * The node&apos;s content description changed. */ public static final int CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION = 0x00000004; 查找节点View系统提供了两个方法让我们来进行查找想要的节点View： 通过节点View的Text内容来查找：findAccessibilityNodeInfosByText(“查找内容”)这种方式查找，就是像TextView,Button等View有文本内容的，可以使用这种方式快速的找到。 nodes = getRootInActiveWindow().findAccessibilityNodeInfosByText(&quot;手机联系人&quot;); if (nodes != null &amp;&amp; nodes.size() &gt; 0) { AccessibilityNodeInfo node = nodes.get(0).getParent(); node.performAction(AccessibilityNodeInfo.ACTION_CLICK); } 第二种是通过节点View在xml布局中的id名称来查找：findAccessibilityNodeInfosByViewId(“@id/xxx”)；(关于怎样找到View在xml布局中的id我下面有说明) nodes = getRootInActiveWindow().findAccessibilityNodeInfosByViewId(&quot;com.tencent.mm:id/f_&quot;); if (nodes != null &amp;&amp; nodes.size() &gt; 0) { for (int i = 0; i &lt; nodes.size(); i++) { node = nodes.get(i).getParent(); node.performAction(AccessibilityNodeInfo.ACTION_CLICK); } } 模拟点击指定事件我们找到我们想要的View节点，调用方法模拟事件： 调用performAction(AccessibilityNodeInfo.ACTION_CLICK)这个方法即可 当然这里的参数就是指定事件的名称，这个和AccessibilityEvent中监听的那些事件是一一对应的，这里是模拟点击事件，我们当然可以模拟View的滚动事件，长按事件等。 实际应用——微信抢红包插件上面我们就介绍了一个辅助功能开发的具体步骤，那么下面就通过一个简单的例子，来实战一下：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Accessibility</tag>
        <tag>辅助功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[底部导航栏凸起效果]]></title>
    <url>%2F2017%2F03%2F15%2FAndroid%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%87%B8%E8%B5%B7%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[先上效果图 此底部导航栏的布局很简单，其中用到的最主要的就是在突出布局的父布局设置android:clipChildren为false即可，默认为true，android:clipChildren的意思：是否限制子View在其范围内，然后设置突出布局android:layout_gravity=”bottom”就可以了 最后贴出代码，使用RadioGroup+RadioButton实现的底部导航 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clipChildren=&quot;false&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewPager android:id=&quot;@+id/vp_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/ViewPager&gt; &lt;View android:id=&quot;@+id/div_view&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1.0px&quot; android:background=&quot;#d9d9d9&quot; /&gt; &lt;RadioGroup android:id=&quot;@+id/rg_group&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;@color/apTabBackground&quot; android:clipChildren=&quot;false&quot; android:elevation=&quot;8dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:id=&quot;@+id/first&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:checked=&quot;true&quot; android:drawableTop=&quot;@drawable/first_selector&quot; android:text=&quot;首页&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/second&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/second_selector&quot; android:text=&quot;学堂&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/third&quot; style=&quot;@style/Bottom_Tab_Style1&quot; android:layout_gravity=&quot;bottom&quot; android:clipChildren=&quot;false&quot; android:drawableBottom=&quot;@drawable/third_selector&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/fourth&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/fourth_selector&quot; android:text=&quot;互动&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/fifth&quot; style=&quot;@style/Bottom_Tab_Style&quot; android:drawableTop=&quot;@drawable/fifth_selector&quot; android:text=&quot;我&quot; android:textSize=&quot;11sp&quot; /&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，技术博客]]></title>
    <url>%2F2017%2F03%2F08%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。第一次写博客，请多多关照]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>